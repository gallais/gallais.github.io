<rss version="2.0"><channel><title>gallais&#39; blog</title><link>http://gallais.github.io/blog/</link><description>gallais&#39; blog</description><item><title>Poltergeist Types</title><link>http://gallais.github.io/blog/poltergeist-types.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Poltergeist Types&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://wiki.haskell.org/Phantom_type&quot;&gt;Haskell wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/idris-lang/Idris2/blob/5946442dc25aadd44d11955753c2d47c6f5027f6/libs/contrib/System/Directory/Tree.idr&quot;&gt;System.Directory.Tree&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;


&lt;p id=chapo&gt;Phantom types are a well-known compile-time tool to ensure that
illegal actions (such as attempting to write in a read-only file) are
unrepresentable. In this blog post we introduce poltergeist types: phantom
types whose parameters may still knock around at runtime.&lt;/p&gt;



&lt;a name=&quot;ALightningIntroductionToPhantomTypes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#ALightningIntroductionToPhantomTypes&quot;&gt;#&lt;/a&gt; A Lightning Introduction to Phantom Types&lt;/h3&gt;



&lt;p&gt;
A phantom type is a parametrised type whose parameters do not show up in
the types of the (usually unique) constructor&#39;s arguments.
They can be used to document whether the arguments are respecting some
invariants. For instance the following definition declares a type of file
handles parametrised by two booleans corresponding to whether the file has
been opened with the ability to read and to write from it.&lt;/p&gt;



&lt;p&gt;If we do not export the &lt;span class=inline-code&gt;MkHandle&lt;/span&gt; constructor
then the only way for a user to manufacture a file handle is to use
the functions we provide. We can make sure that these functions enforce
that the parameters are always set to reflect the file handle&#39;s status.
&lt;/p&gt;



&lt;p class=code&gt;data Handle : (read, write : Bool) -&gt; Type where
  MkHandle : AnyPtr -&gt; Path r w
&lt;/p&gt;



&lt;p&gt;We can now make sure that we only attempt to get a line from a file we
are allowed to read from by insisting that the &lt;span class=inline-code&gt;read&lt;/span&gt;
parameter of the handle we pass to &lt;span class=inline-code&gt;fGetLine&lt;/span&gt; is
&lt;span class=inline-code&gt;True&lt;/span&gt;.
Similarly we can restrict &lt;span class=inline-code&gt;fPutStr&lt;/span&gt; to file handles
where we statically know that we are allowed to write.
&lt;/p&gt;



&lt;p class=code&gt;fGetLine : Handle True write -&gt; IO String
fPutStr  : Handle read True -&gt; String -&gt; IO ()
&lt;/p&gt;



&lt;p&gt;
Note that in both cases we only restrict the parameter of interest, leaving
the other one as polymorphic as possible so that we may use
&lt;span class=inline-code&gt;fGetLine&lt;/span&gt; with both read-only and read-write files.
If we need to we can enfore more constraints or no constraints whatsoever
e.g. reversing a file will require the ability to read and write to it but
closing a handle is completely agnostic with respect to the handle&#39;s
capabilities.
&lt;/p&gt;



&lt;p&gt;The example we just saw is set in a dependently typed language but is not
specific to it. In OCaml for instance, we could define a largely similar
interface with the exception that the parameters of the
&lt;span class=inline-code&gt;Handle&lt;/span&gt; phantom type would be types themselves and
not the boolean &lt;i&gt;values&lt;/i&gt; we used.

Apart from this small change, the code would be largely the same and the runtime
behaviour virtually identical. In particular all of the parameters would be
erased at runtime
&lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt;.
&lt;/p&gt;



&lt;p&gt;The dependently typed setting however allows us to ask whether we would
sometimes want the parameters&#39; values to be available at runtime.
&lt;/p&gt;



&lt;a name=&quot;PoltergeistTypes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#PoltergeistTypes&quot;&gt;#&lt;/a&gt; Poltergeist Types&lt;/h3&gt;



&lt;p&gt;
For this case study we want to devise a high level representation of a directory
tree. Up until now the only way to interact with the file system in Idris was to
use some very low-level primitives: &lt;span class=inline-code&gt;openDir&lt;/span&gt; would take
a string and, provided that it represents a valid directory path, would return a
pointer representing the directory.
You could then repeatedly call &lt;span class=inline-code&gt;dirEntry&lt;/span&gt; with that
pointer to get your hands on directory entries one by one. Once you were done
you would need to remember to call (exactly once!)
&lt;span class=inline-code&gt;closeDir&lt;/span&gt; to free the pointer.
This leads to extremely imperative code with no separation of concerns:
in any function the exploration of the directory tree is intimately interleaved
with the function&#39;s own internal logic.
&lt;/p&gt;



&lt;p&gt;
Our solution is to describe a directory tree as a record containing
a list of file names and
a list of directory names each paired with an &lt;span class=inline-code&gt;IO&lt;/span&gt;
computation delivering the tree corresponding to the subdirectory. We can
provide a generic function building such a tree and then users can explore
it without having to bother with manipulating pointers.
The final decision is to pick how to represent these file names and directory
names.
We could use absolute paths but that would involve a lot of information
duplication as all the names in the tree share a common prefix.
We could alternatively use base names but that would force users
to reconstruct absolute paths when exploring the tree if they actually need
them which seems like an error-prone process.
Instead we opt for a phantom type: a &lt;span class=inline-code&gt;FileName&lt;/span&gt; is
parametrised by its root but only stores the basename as a string.
&lt;/p&gt;



&lt;p class=code&gt;data FileName : Path -&gt; Type where
  MkFileName : String -&gt; FileName root
&lt;/p&gt;



&lt;p&gt;
And here is where we depart from classic phantom types: a user needing
access to the full file path can call &lt;span class=inline-code&gt;toFilePath&lt;/span&gt;
on a &lt;span class=inline-code&gt;FileName root&lt;/span&gt;
which will, provided that the &lt;span class=inline-code&gt;root&lt;/span&gt; is runtime-relevant,
compute the appropriate answer.
&lt;/p&gt;



&lt;p class=code&gt;toFilePath : {root : Path} -&gt; FileName root -&gt; String
toFilePath file = show (root /&gt; file)
&lt;/p&gt;



&lt;p&gt;
We can finally give the definition of a &lt;span class=inline-code&gt;Tree&lt;/span&gt; we only
sketched earlier. A tree is a record anchored at a &lt;span class=inline-code&gt;root&lt;/span&gt;
and it comprises a list of file names as well as a list of subtrees both of
which are anchored at that same root.
&lt;/p&gt;



&lt;p class=code&gt;record Tree (root : Path) where
  constructor MkTree
  files    : List (FileName root)
  subTrees : List (SubTree root)
&lt;/p&gt;



&lt;p&gt;
The key definition is that of the notion of subtrees. It is a dependent pair
storing a file name (the name of the directory) and an IO computation returning
a tree anchored at the parent&#39;s root extended with the name of the subdirectory.
This definition gives us the best of both worlds: the file names are only
storing the base names, but the user never has to explicitly reconstruct the
path when they explore a given tree. Indeed our definition guarantees
that the path is automatically extended when entering a subdirectory, and that
this extended path is used when calling &lt;span class=inline-code&gt;toFilePath&lt;/span&gt;.
&lt;p&gt;

&lt;p class=code&gt;SubTree : Path -&gt; Type
SubTree root = (dir : FileName root ** IO (Tree (root /&gt; dir)))
&lt;/p&gt;

&lt;/p&gt;
When writing a function consuming a &lt;span class=inline-code&gt;Tree&lt;/span&gt; we can leave
the parameter implicit (marking it erased or not depending on whether we
actually need this information at runtime)
and let Idris reconstruct the appropriate value by unification when performing
a recursive call.
We show below the type of two different traversals provided by the
&lt;span class=inline-code&gt;System.Directory.Tree&lt;/span&gt; library:
&lt;span class=inline-code&gt;print&lt;/span&gt; only uses base names to display the tree in the
console and as such its &lt;span class=inline-code&gt;root&lt;/span&gt; argument is guaranteed to
be erased. The &lt;span class=inline-code&gt;findFile&lt;/span&gt; function however looks for a
file whose basename matches a given string and returns a full path. As such it
needs to have access to the value of &lt;span class=inline-code&gt;root&lt;/span&gt; and that is
why it is explicitly introduced with an unrestricted modality.
&lt;/p&gt;



&lt;p class=code&gt;print    : Tree root -&gt; IO ()
findFile : {root : Path} -&gt; String -&gt; Tree root -&gt; IO (Maybe Path)
&lt;/p&gt;



&lt;a name=&quot;Conclusion&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Conclusion&quot;&gt;#&lt;/a&gt; Conclusion&lt;/h3&gt;



&lt;p&gt;
We have seens that instead of storing potentially useless information in a data
structure, or forcing users to carefully reconstruct it on the fly were they to
need it, we can instead parametrise our data structure over this information in
such a way that if it is needed then it will be automatically reconstructed by
the type system for us.

This gives us a new kind of types that are phantom in the sense that their
payloads are not influenced by their parameters but whose parameters may yet
manifest themselves physically at runtime. We call them poltergeists.
&lt;/p&gt;

&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;
In Idris the variables in a type that are not explicitly bound are implicitly
universally quantified in a prenex position with quantity 0 i.e. they are
runtime-irrelevant.
In the type of &lt;span class=inline-code&gt;fGetLine&lt;/span&gt; for instance, the boolean
variable &lt;span class=inline-code&gt;write&lt;/span&gt; is therefore universally quantified,
and marked as erased.
The same thing applies to the variable &lt;span class=inline-code&gt;read&lt;/span&gt; in the
type of &lt;span class=inline-code&gt;fPutStr&lt;/span&gt;.
&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/poltergeist-types.html</guid><pubDate>Fri, 16 Apr 2021 13:37:00 UTC</pubDate></item><item><title>Ceci n&#39;est pas un default</title><link>http://gallais.github.io/blog/ceci-pas-default.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Ceci n&#39;est pas un default&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;
    &lt;a href=&quot;https://github.com/gallais/potpourri/blob/a20fed3c4b7e46c0683eba55788d07f09bbaf776/haskell/defaulting/Default.hs&quot;&gt;Default.hs&lt;/a&gt;
&lt;/li&gt;
&lt;li&gt;
    &lt;a href=&quot;https://github.com/agda/agda/blob/6f3046e081ebfa40793c3a064e53bdbd83c82dcf/src/full/Agda/Utils/WithDefault.hs&quot;&gt;In Agda&#39;s codebase&lt;/a&gt;
&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;


&lt;p id=chapo&gt;Being the default value is not the same as being actively set
to a value which happens to match the default. &lt;tt&gt;Maybe&lt;/tt&gt; as a type
constructor enriching an existing type with a default value is not
satisfactory: what this default value means is not documented in the
type.
&lt;/p&gt;



&lt;p&gt;
When designing a command line interface, it is quite often necessary to
provide default values for some of the flags.&lt;/p&gt;



&lt;p&gt;
Sometimes there is only one sensible choice and it is simply picked when
initialising the record of options. In Agda for instance we set the default
verbosity to 1 (the bigger the number, the more detailed the debugging
information) and ask for the empty context (the more specific the context,
the more irrelevant information is filtered out).
&lt;/p&gt;



&lt;p&gt;
Other times, there are multiple sensible choices and they may be incompatible.
In Agda, both guardedness checking and sized types can be used to program with
codata. But combining the two makes the system unsound. By default we want
users to be able to use both so both are turned on. However if they use the
&lt;tt&gt;--safe&lt;/tt&gt; flag, they should only be allowed to use at most one. We want
to shout at the user if they actively turn both on and declare the module 
should be safe. So we need to distinguish between the flags being set to
the default and them being actively set to a value which happens to match the
default.
&lt;/p&gt;



&lt;a name=&quot;KeyIdea:AFancyMaybe&quot; /&gt;
&lt;h2&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#KeyIdea:AFancyMaybe&quot;&gt;#&lt;/a&gt; Key Idea: A Fancy Maybe&lt;/h2&gt;



&lt;p&gt;
We could be using &lt;tt&gt;Maybe&lt;/tt&gt; as the type constructor extending a type
with a default value. However the design choices are now scattered in a
lot of different places:
&lt;ul&gt;&lt;li&gt; sensible defaults are set in the initial record value,
&lt;/li&gt;
&lt;li&gt; the choice to use &lt;tt&gt;Maybe&lt;/tt&gt; to add a neutral default value is
     made explicit in the type,
&lt;/li&gt;
&lt;li&gt; but this default value is declared somewhere else e.g. in a cleanup
     function computing the final set of options,
&lt;/li&gt;
&lt;li&gt; if we collapse &lt;tt&gt;Maybe a&lt;/tt&gt; to &lt;tt&gt;a&lt;/tt&gt; in multiple locations,
     we need to be consistent and make sure that we use the same default
     everywhere.
&lt;/li&gt;&lt;/ul&gt;
This situation is not very satisfactory. And it turns out that we can do
better with a little bit of type-level programming. We start with a fancy
version of &lt;tt&gt;Maybe&lt;/tt&gt; which is parametrised not only by a type but also
by a type-level value of that type.&lt;/p&gt;



&lt;p class=code&gt;data WithDefault k (a :: k) where
  Default :: WithDefault k a
  Value   :: k -&gt; WithDefault k a
&lt;/p&gt;



&lt;p&gt;
When we write &lt;span class=inline-code&gt;WithDefault Bool &#39;True&lt;/span&gt; we explicitly
tell the reader that our &lt;tt&gt;Maybe&lt;/tt&gt;-looking optional type will default
to &lt;tt&gt;True&lt;/tt&gt; unless the value has been set. We can start by writing
the function which let us set a value. In case it&#39;s been set already we
simply ignore the new value.
&lt;/p&gt;



&lt;p class=code&gt;setDefault :: k -&gt; WithDefault k a -&gt; WithDefault k a
setDefault k v = case v of
  Default -&gt; Value k
  _ -&gt; v
&lt;/p&gt;



&lt;a name=&quot;section0&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section0&quot;&gt;#&lt;/a&gt; Turning &lt;tt&gt;Default&lt;/tt&gt; into the default.&lt;/h3&gt;



&lt;p&gt;
Now that we can set the value, it&#39;s only natural to want to also get it.
In case it still is the &lt;tt&gt;Default&lt;/tt&gt;, we need to be able to produce the
term-level value which corresponds to the type level one. To do that we need
some extra machinery.
&lt;/p&gt;



&lt;p&gt;
The &lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2503786&quot;&gt;hasochistic&lt;/a&gt; device
that allows us to connect term and type levels is naturally the notion of
&lt;a href=&quot;https://dl.acm.org/citation.cfm?id=2364522&quot;&gt;singletons&lt;/a&gt;. We postulate
the existence of a data family of singletons, that is to say that to each
type-level constructor should correspond a term-level one indexed by it.
&lt;/p&gt;



&lt;p class=code&gt;data family Sing k (a :: k)
&lt;/p&gt;



&lt;p&gt;
We say that a type-level value is &lt;tt&gt;Known&lt;/tt&gt; if we can obtain a singleton
for it. We also assume that if a value is known then we are able to erase a
singleton for it down to its mere term level value.
&lt;/p&gt;



&lt;p class=code&gt;class Known k (a :: k) | a -&gt; k where
  sing  :: Sing k a
  erase :: Sing k a -&gt; k
&lt;/p&gt;



&lt;p&gt;
Now that we have the ability to turn a type-level value into a term level one,
we can write a function out of &lt;tt&gt;WithDefault&lt;/tt&gt;. It is essentially the
function &lt;tt&gt;fromMaybe&lt;/tt&gt; except that we do not need to specify what to do
in case we find our &lt;tt&gt;Nothing&lt;/tt&gt;-like constructor: provided that the
type-level value is &lt;tt&gt;Known&lt;/tt&gt;, the type itself tells us what the output
should be.
&lt;/p&gt;



&lt;p class=code&gt;collapseDefault :: forall k a. Known k a =&gt; WithDefault k a -&gt; k
collapseDefault x = case x of
  Default -&gt; erase (sing :: Sing k a)
  Value v -&gt; v
&lt;/p&gt;



&lt;p&gt;
So what do instances of these data and class definitions look like?
&lt;/p&gt;



&lt;a name=&quot;FirstInstance:BooleanLiterals&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#FirstInstance:BooleanLiterals&quot;&gt;#&lt;/a&gt; First instance: Boolean literals&lt;/h3&gt;



&lt;p&gt;
Using a Generalized Algebraic DataType (GADT), we define the singleton
for booleans like so: &lt;tt&gt;STrue&lt;/tt&gt; is the term-level constructor
reflecting the type-level &lt;tt&gt;&#39;True&lt;/tt&gt; whilst &lt;tt&gt;SFalse&lt;/tt&gt; corresponds
to &lt;tt&gt;&#39;False&lt;/tt&gt;. This makes both &lt;tt&gt;&#39;True&lt;/tt&gt; and &lt;tt&gt;&#39;False&lt;/tt&gt;
known booleans: we have singletons for them and can easily produce the
underlying &lt;tt&gt;Bool&lt;/tt&gt;.
&lt;/p&gt;



&lt;p class=code&gt;data instance Sing Bool b where
  STrue  :: Sing Bool &#39;True
  SFalse :: Sing Bool &#39;False

instance Known Bool &#39;True where
  sing = STrue
  erase _ = True

instance Known Bool &#39;False where
  sing = SFalse
  erase _ = False
&lt;/p&gt;



&lt;p&gt;Using these instances, we can already write some examples. Evaluating
the following expression yields the expected list
&lt;span class=inline-code&gt;[False,True,True]&lt;/span&gt;&lt;/p&gt;



&lt;p class=code&gt;bool :: [Bool]
bool = collapseDefault &lt;$&gt;
     [ Value False
     , Value True
     , Default :: WithDefault Bool &#39;True
     ]
&lt;/p&gt;



&lt;a name=&quot;PolymorphicInstances&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#PolymorphicInstances&quot;&gt;#&lt;/a&gt; Polymorphic Instances&lt;/h3&gt;



&lt;p&gt;
We are not limited to ground types: we can give instances for polymorphic
container types by assuming we have instances for the elements they store.
This is where the fact that &lt;tt&gt;Sing&lt;/tt&gt; is a data family of singletons
shines: we have a unique name for all of these constructs. Let us define
the following singleton datatype for &lt;tt&gt;Maybe&lt;/tt&gt;:
&lt;/p&gt;



&lt;p class=code&gt;data instance Sing (Maybe a) m where
  SNothing :: Sing (Maybe a) &#39;Nothing
  SJust    :: Sing a v -&gt; Sing (Maybe a) (&#39;Just v)
&lt;/p&gt;



&lt;p&gt;
The type-level constructor &lt;tt&gt;&#39;Nothing&lt;/tt&gt; is evidently known: its
singleton is &lt;tt&gt;SNothing&lt;/tt&gt; and it erases to the term level value
&lt;tt&gt;Nothing&lt;/tt&gt;.
&lt;/p&gt;



&lt;p class=code&gt;instance Known (Maybe a) &#39;Nothing where
  sing = SNothing
  erase _ = Nothing
&lt;/p&gt;



&lt;p&gt;
We can only say that &lt;tt&gt;&#39;Just v&lt;/tt&gt; is known if &lt;tt&gt;v&lt;/tt&gt; itself
already is. We obtain the right singleton by using the assumption
that &lt;tt&gt;v&lt;/tt&gt; is known to obtain a singleton for it and wrap it
in an &lt;tt&gt;SJust&lt;/tt&gt; constructor. Erasure is defined in a similar
manner: we output &lt;tt&gt;Just&lt;/tt&gt; and use &lt;tt&gt;erase&lt;/tt&gt; to compute
its content.
&lt;/p&gt;



&lt;p class=code&gt;instance Known a v =&gt; Known (Maybe a) (&#39;Just v) where
  sing            = SJust sing
  erase (SJust v) = Just (erase v)
&lt;/p&gt;



&lt;p&gt;
We have similar instances for lists and pairs.
&lt;/p&gt;



&lt;a name=&quot;DealingWithText&quot; /&gt;
&lt;h2&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#DealingWithText&quot;&gt;#&lt;/a&gt; Dealing with Text&lt;/h2&gt;



&lt;p&gt;
Unfortunately the current setup means we cannot state that we expect to
be given a string but will happily default to &quot;Hello&quot; if we are not given
anything. GHC does provide us with &lt;tt&gt;Symbol&lt;/tt&gt;, the kind of type-level
strings. So we ought to be able to also support default values for various
string types such as &lt;tt&gt;Text&lt;/tt&gt;.
&lt;/p&gt;



&lt;p&gt;
The trick here is to decorrelate the kind of the type-level value and the
type it represents. Instead of the &lt;tt&gt;WithDefault&lt;/tt&gt; type we defined
earlier, we use the following more general one as our core representation.
The original &lt;tt&gt;WithDefault&lt;/tt&gt; is the special case where kind and type
do match up.
&lt;/p&gt;



&lt;p class=code&gt;data WithDefault k (a :: l) where
  Default :: WithDefault k a
  Value   :: k -&gt; WithDefault k a
&lt;/p&gt;



&lt;p&gt;
This change needs to be propagated through all the families, classes,
instance declarations, and functions. The interested reader can check
the &lt;a href=&quot;https://github.com/gallais/potpourri/blob/a20fed3c4b7e46c0683eba55788d07f09bbaf776/haskell/defaulting/Default.hs&quot;&gt;Haskell file&lt;/a&gt;. We choose
to focus here on the &lt;tt&gt;Text&lt;/tt&gt; instance.
&lt;/p&gt;



&lt;p&gt;
We can&#39;t quite define an enumerated type providing a constructor for each
string in existence. However the kind people at GHC&#39;s HQ are already doing
this for us:
&lt;a href=&quot;https://hackage.haskell.org/package/base-4.12.0.0/docs/GHC-TypeLits.html&quot;&gt;&lt;tt&gt;GHC.TypeLits&lt;/tt&gt;&lt;/a&gt;
gives us access to &lt;tt&gt;KnownSymbol&lt;/tt&gt;. Our data instance for &lt;tt&gt;Text&lt;/tt&gt;
is capturing a constraint of the form &lt;tt&gt;KnownSymbol s&lt;/tt&gt; as the notion
of singleton for &lt;tt&gt;s&lt;/tt&gt;.
&lt;/p&gt;



&lt;p class=code&gt;data instance Sing Text (s :: Symbol) where
  SText :: KnownSymbol s =&gt; Sing Text s
&lt;/p&gt;



&lt;p&gt;
Using the GHC-provided function &lt;tt&gt;symbolVal&lt;/tt&gt;, we can obtain a
&lt;tt&gt;String&lt;/tt&gt; corresponding to a given &lt;tt&gt;KnownSymbol&lt;/tt&gt;. As a
consequence, if &lt;tt&gt;s&lt;/tt&gt; is a known symbol, we can trivially build
a proof that it is a &lt;tt&gt;Known Text&lt;/tt&gt; too.
&lt;/p&gt;



&lt;p class=code&gt;instance KnownSymbol s =&gt; Known Text (s :: Symbol) where
  sing  = SText
  erase = pack . symbolVal
&lt;/p&gt;



&lt;p&gt;
Although the instance declarations are now a bit more verbose, the user
experience is virtually the same. And we now support string literals.
The following test showcasing all of the instances mentioned in this post
evaluates to the list
&lt;span class=inline-code&gt;[[(True,Just &quot;Hello World&quot;)],[(False,Nothing)]]&lt;/span&gt;:
&lt;/p&gt;


&lt;p class=code&gt;test :: [[(Bool, Maybe Text)]]
test = collapseDefault &lt;$&gt;
     [ Default :: WithDefault [(Bool, Maybe Text)]
                  &#39;[ &#39;( &#39;True , &#39;Just &quot;Hello World&quot;) ]
     , Value [(False, Nothing)]
     ]
&lt;/p&gt;



&lt;a name=&quot;WrapUp&quot; /&gt;
&lt;h2&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#WrapUp&quot;&gt;#&lt;/a&gt; Wrap up&lt;/h2&gt;



&lt;p&gt;
We have seen that we can define an optional type indexed by the value
it should default to. Using standard type-level trickery we can write
the function collapsing the &lt;tt&gt;Default&lt;/tt&gt; constructor to the value
specified in the type. Although this most general version works well,
it requires fairly recent &lt;tt&gt;LANGUAGE&lt;/tt&gt; extensions so
&lt;a href=&quot;https://github.com/agda/agda/blob/6f3046e081ebfa40793c3a064e53bdbd83c82dcf/src/full/Agda/Utils/WithDefault.hs&quot;&gt;we are not using it in the Agda codebase&lt;/a&gt;,
limiting ourselves to the special case of the &lt;tt&gt;Bool&lt;/tt&gt; version.
&lt;/p&gt;

</description><guid isPermaLink="true">http://gallais.github.io/blog/ceci-pas-default.html</guid><pubDate>Mon, 11 Mar 2019 13:37:00 UTC</pubDate></item><item><title>First Cubical Experiment</title><link>http://gallais.github.io/blog/first-cubical-experiment.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;First Cubical Experiment&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://agda.readthedocs.io/en/latest/language/cubical.html&quot;&gt;Cubical Agda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gallais/potpourri/blob/efdfa3e5f84953666dfd9b98499ae9136ade570b/agda/cubical/list0.agda&quot;&gt;list0.agda&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;


&lt;p id=chapo&gt;
With Agda version 2.6.0 close to being released, I decided
to experiment with cubical Agda.
&lt;/p&gt;



&lt;p&gt;
Now that &lt;a href=&quot;https://agda.readthedocs.io/en/latest/language/cubical.html&quot;&gt;the
documentation for cubical Agda&lt;/a&gt; is available, it should be easier to start
experimenting. I first tried to formalise Frumin, Geuvers, Gondelman, and van
der Weide&#39;s &lt;a href=&quot;https://dl.acm.org/citation.cfm?id=3167085&quot;&gt;Finite Sets in
Homotopy Type Theory&lt;/a&gt;. However I got stuck trying to write the very first
function when I had to figure out what a path&#39;s image was. Time to go back to
basics!
&lt;/p&gt;



&lt;a name=&quot;section0&quot; /&gt;
&lt;h2&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section0&quot;&gt;#&lt;/a&gt; A basic datatype: &lt;tt&gt;List⁰&lt;/tt&gt;&lt;/h2&gt;



&lt;p&gt;
My attempt to boil down the problem I was facing resulted in &lt;tt&gt;List⁰&lt;/tt&gt;.
It is a higher inductive type of strange lists: we have the two usual list
constructors, together with a path saying that a non-empty list is equal to
its tail.
&lt;/p&gt;



&lt;p class=code&gt;data List⁰ (A : Set) : Set where
  []  : List⁰ A
  _∷_ : A → List⁰ A → List⁰ A
  del : ∀ x e → x ∷ e ≡ e
&lt;/p&gt;



&lt;p&gt;
Hopefully, this mix of the familiar and the new will let us build on our
old intuitions to understand new concepts. We can start by revisiting a
function we know very well in the list case.
&lt;/p&gt;



&lt;a name=&quot;section1&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section1&quot;&gt;#&lt;/a&gt; Appending two &lt;tt&gt;List⁰&lt;/tt&gt;&lt;/h3&gt;



&lt;p&gt;
We define append by recursion on the first list. The first two cases
are similar to what one would do in Haskell (or vanilla Agda): if the first
list is empty, we return the second one; and if it has a head and a tail,
we cons the head and the result of the recursive call on the tail. But there
is also a third case: &lt;tt&gt;List⁰&lt;/tt&gt; is a higher inductive type and that means
that we need to explain how append acts on paths!
&lt;/p&gt;



&lt;p class=code&gt;_++_ : (e f : List⁰ A) → List⁰ A
[]        ++ f = f
(x ∷ e)   ++ f = x ∷ (e ++ f)
del x e i ++ f = ?
&lt;/p&gt;



&lt;p&gt;
Because the function &lt;tt&gt;_++_&lt;/tt&gt; acts on elements of &lt;tt&gt;List⁰ A&lt;/tt&gt;,
we need its first argument to be of type &lt;tt&gt;List⁰ A&lt;/tt&gt;. For this reason,
the case mentions &lt;span class=inline-code&gt;del x e i&lt;/span&gt;: a value at position &lt;tt&gt;i&lt;/tt&gt;
along the line of type &lt;span class=inline-code&gt;x ∷ e ≡ e&lt;/span&gt; described by &lt;tt&gt;del&lt;/tt&gt;.
The type of the hole is &lt;tt&gt;List⁰ A&lt;/tt&gt; but it does not mean that we can put just
about any expression in: there are side conditions!
&lt;/p&gt;



&lt;p&gt;
These sides conditions can be understood from a very practical point of view:
if &lt;tt&gt;i&lt;/tt&gt; gets instantiated to either &lt;tt&gt;i0&lt;/tt&gt; or &lt;tt&gt;i1&lt;/tt&gt;, the value
of &lt;span class=inline-code&gt;del x e i ++ f&lt;/span&gt; should not depend on whether we
evaluate &lt;tt&gt;_++_&lt;/tt&gt; first and then instantiate &lt;tt&gt;i&lt;/tt&gt;, or the converse.
To guarantee that evaluation is confluent, Agda demands that both reductions
lead to judgmentally equal values.
&lt;/p&gt;



&lt;p&gt;
Understanding where these constraints come from, we can compute them. Remembering
that if &lt;tt&gt;p&lt;/tt&gt; has type &lt;span class=inline-code&gt;a ≡ b&lt;/span&gt; then &lt;span class=inline-code&gt;p i0 = a&lt;/span&gt;
and &lt;span class=inline-code&gt;p i1 = b&lt;/span&gt;:
&lt;/p&gt;



&lt;p class=code&gt;i = i0 ⊢ del x e i ++ f    { del x e i0 = x ∷ e }
       = x ∷ e     ++ f    { unfold _++_ }
       = x ∷ (e ++ f)

i = i1 ⊢ del x e i ++ f    { del x e i1 = e }
       = e ++ f
&lt;/p&gt;



&lt;p&gt;
So, the expression we pick to fill in the &lt;tt&gt;List⁰ A&lt;/tt&gt; will need to be
equal to &lt;span class=inline-code&gt;x ∷ (e ++ f)&lt;/span&gt; if &lt;tt&gt;i&lt;/tt&gt; is &lt;tt&gt;i0&lt;/tt&gt;
and &lt;span class=inline-code&gt;e ++ f&lt;/span&gt; if &lt;tt&gt;i&lt;/tt&gt; is &lt;tt&gt;i1&lt;/tt&gt;.
Observing that &lt;span class=inline-code&gt;del x (e ++ f)&lt;/span&gt; has type
&lt;span class=inline-code&gt;x ∷ (e ++ f) ≡ e ++ f&lt;/span&gt;, we pick the following
solution:
&lt;/p&gt;



&lt;p class=code&gt;del x e i ++ f = del x (e ++ f) i
&lt;/p&gt;



&lt;p&gt;
Agda performs the checks we have mentioned earlier and sees that our
solution is indeed compatible with the equations we already had. We
now have a fully-defined function. Time to prove some of its properties!
&lt;/p&gt;



&lt;a name=&quot;ProvingThePropertiesOfAppend&quot; /&gt;
&lt;h2&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#ProvingThePropertiesOfAppend&quot;&gt;#&lt;/a&gt; Proving the Properties of Append&lt;/h2&gt;



&lt;p&gt;
Just like for lists, we can prove that &lt;span class=inline-code&gt;[]&lt;/span&gt; is a neutral
element for the binary operation &lt;span class=inline-code&gt;_++_&lt;/span&gt;. That is to say
that both &lt;span class=inline-code&gt;[] ++_&lt;/span&gt; and &lt;span class=inline-code&gt;_++ []&lt;/span&gt;
are the identity function. This should not be too much work but it will get us
the opportunity to think about what happens in the &lt;span class=inline-code&gt;del&lt;/span&gt;
case. We will then prove a more complex result: given that &lt;span class=inline-code&gt;del&lt;/span&gt;
allows us to peel-off the head of a non-empty list, we should be able to prove
that we can ``cancel&#39;&#39; append, that is to say that &lt;span class=inline-code&gt;e ++ f&lt;/span&gt;
is equal to &lt;span class=inline-code&gt;f&lt;/span&gt;.
&lt;/p&gt;



&lt;a name=&quot;LeftAndRightIdentities&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#LeftAndRightIdentities&quot;&gt;#&lt;/a&gt; Left and Right Identities&lt;/h3&gt;



&lt;p&gt;
The left identity holds by computation: the definition of append itself declares
that &lt;span class=inline-code&gt;[] ++ e&lt;/span&gt; should reduce to &lt;span class=inline-code&gt;e&lt;/span&gt;.
We can use &lt;span class=inline-code&gt;refl&lt;/span&gt; to prove the goal like we would do in
vanilla Agda. The main difference here being that &lt;span class=inline-code&gt;refl&lt;/span&gt; is
not a constructor: it is the constant function which given any value in the interval
returns &lt;span class=inline-code&gt;e&lt;/span&gt;.
&lt;/p&gt;



&lt;p class=code&gt;++-idˡ : (e : List⁰ A) → [] ++ e ≡ e
++-idˡ e = refl
&lt;/p&gt;



&lt;p&gt;
The right identity requires a bit more work: given that append is defined by
recursion on its first argument, we need to proceed by induction on it. The first
two cases are what you would expect from the proof of
&lt;a href=&quot;https://agda.github.io/agda-stdlib/v0.17/Data.List.Properties.html#4357&quot;&gt;
a similar result on lists&lt;/a&gt;.
&lt;/p&gt;



&lt;p class=code&gt;++-idʳ : (e : List⁰ A) → e ++ [] ≡ e
++-idʳ []          = refl
++-idʳ (x ∷ e)     = cong (x ∷_) (++-idʳ e)
++-idʳ (del x e i) = ?
&lt;/p&gt;



&lt;p&gt;
The last case is not a lot more complicated, at least at first glance:
&lt;ul&gt;&lt;li&gt;the left hand side of the equality goal is &lt;span class=inline-code&gt;del x e i ++ []&lt;/span&gt;
which reduces to &lt;span class=inline-code&gt;del x (e ++ []) i&lt;/span&gt; by definition of
append&lt;/li&gt;
&lt;li&gt;the right hand side is &lt;span class=inline-code&gt;del x e i&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;
A natural candidate for this equality is to use the induction hypothesis to
obtain a proof that &lt;span class=inline-code&gt;e ++ [] ≡ e&lt;/span&gt; and use congruence
to apply the function &lt;span class=inline-code&gt;λ e → del x e i&lt;/span&gt; to each side.
However remember that we need to check that this definition is compatible with
the other clauses when &lt;tt&gt;i&lt;/tt&gt; becomes either &lt;tt&gt;i0&lt;/tt&gt; or &lt;tt&gt;i1&lt;/tt&gt;.
This gives us the following constraints:
&lt;/p&gt;



&lt;p class=code&gt;i = i0 ⊢ ++-idʳ (del x e i)       { del x e i0 = x ∷ e }
       = ++-idʳ (x ∷ e)           { unfold ++-idʳ }
       = cong (x ∷_) (++-idʳ e)

i = i1 ⊢ ++-idʳ (del x e i)       { del x e i1 = e }
       = ++-idʳ e
&lt;/p&gt;



&lt;p&gt;
We can easily verify that &lt;span class=inline-code&gt;cong (λ e → del x e i) (++-idʳ e)&lt;/span&gt;
does collapse to the right expressions when we set &lt;tt&gt;i&lt;/tt&gt; to either &lt;tt&gt;i0&lt;/tt&gt; or
&lt;tt&gt;i1&lt;/tt&gt; thanks in part to the fact that &lt;span class=inline-code&gt;cong (λ x → x) p&lt;/span&gt;
is definitionally equal to &lt;span class=inline-code&gt;p&lt;/span&gt;. This leads us to the following
completed definition:
&lt;/p&gt;



&lt;p class=code&gt;++-idʳ : (e : List⁰ A) → e ++ [] ≡ e
++-idʳ []          = refl
++-idʳ (x ∷ e)     = cong (x ∷_) (++-idʳ e)
++-idʳ (del x e i) = cong (λ e → del x e i) (++-idʳ e)
&lt;/p&gt;



&lt;p&gt;We can now move on to a more difficult proof.&lt;/p&gt;



&lt;a name=&quot;CancellingAppend&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#CancellingAppend&quot;&gt;#&lt;/a&gt; Cancelling append&lt;/h3&gt;



&lt;p&gt;
Given that a non-empty list is declared equal to its tail it should be possible
to prove that if we append two lists, the result is equal to the second one alone.
The intuition being that we can repeatedly use &lt;span class=inline-code&gt;del&lt;/span&gt; to
consume all of the elements in the first list. Formally, this gives us the type:
&lt;/p&gt;



&lt;p class=code&gt;dels : (e f : List⁰ A) → e ++ f ≡ f
&lt;/p&gt;



&lt;p&gt;Remarking once more that append is defined by recursion on its first argument,
we proceed by induction on it. The first case is easily dealt with: it is precisely
the left identity law for append which we know holds definitionally. For uniformity
with the upcoming case, we eta-expand &lt;span class=inline-code&gt;refl&lt;/span&gt; and write &lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt;:
&lt;/p&gt;



&lt;p class=code&gt;dels [] f j = f
&lt;/p&gt;



&lt;p&gt;The second clause demands an equality proof between
&lt;span class=inline-code&gt;x ∷ e ++ f&lt;/span&gt; on the one hand and
&lt;span class=inline-code&gt;f&lt;/span&gt; on the other. We could use
transitivity to combine a call to &lt;span class=inline-code&gt;del&lt;/span&gt;
taking us from &lt;span class=inline-code&gt;x ∷ e ++ f&lt;/span&gt; to
&lt;span class=inline-code&gt;e ++ f&lt;/span&gt; and then use the induction
hypothesis to conclude. However it turns out that we can
find a more compact proof by defining the path explicitly.
We write:
&lt;/p&gt;



&lt;p class=code&gt;dels (x ∷ e) f j = del x (dels e f j) j
&lt;/p&gt;



&lt;p&gt;
We let the reader check that when &lt;tt&gt;j&lt;/tt&gt; is &lt;tt&gt;i0&lt;/tt&gt; we
do get &lt;span class=inline-code&gt;x ∷ e ++ f&lt;/span&gt; whilst making &lt;tt&gt;j&lt;/tt&gt;
equal to &lt;tt&gt;i1&lt;/tt&gt; takes us to &lt;span class=inline-code&gt;f&lt;/span&gt;.
We are now left with the last clause. We need a term of type
&lt;span class=inline-code&gt;del x e i ++ f ≡ f&lt;/span&gt; which satisfies the
usual two side conditions stating that when we make &lt;tt&gt;i&lt;/tt&gt;
either &lt;tt&gt;i0&lt;/tt&gt; or &lt;tt&gt;i1&lt;/tt&gt;, it is compatible with the previous
clauses.
&lt;/p&gt;



&lt;p class=code&gt;i = i0 ⊢ dels (del x e i) f j       { del x e i0 = x ∷ e }
       = dels (x ∷ e) f j           { unfold dels }
       = del x (dels e f j) j

i = i1 ⊢ dels (del x e i) f j       { del x e i1 = e }
       = dels e f j
&lt;/p&gt;



&lt;p&gt;It is hard to give an intuition for the jump from these constraints
to the solution. One thing we can notice is that &lt;span class=inline-code&gt;dels e f j&lt;/span&gt;
is the right hand side of the equality proved by &lt;span class=inline-code&gt;del x (dels e f j)&lt;/span&gt;.
So we need to somehow get a term which is equal &lt;span class=inline-code&gt;del x (dels e f j) j&lt;/span&gt;
when &lt;tt&gt;i&lt;/tt&gt; is &lt;tt&gt;i0&lt;/tt&gt; and collapses to &lt;span class=inline-code&gt;del x (dels e f j)&lt;/span&gt;&#39;s
right hand side when &lt;tt&gt;i&lt;/tt&gt; is &lt;tt&gt;i1&lt;/tt&gt;.&lt;/p&gt;



&lt;p&gt;
The key idea in cubical Agda which will help us here is the fact that
&lt;a href=&quot;https://agda.readthedocs.io/en/latest/language/cubical.html#the-interval-and-path-types&quot;&gt;
elements of the interval form a De Morgan algebra&lt;/a&gt;. We can use the interval
value &lt;span class=inline-code&gt;i ∨ j&lt;/span&gt;: when &lt;tt&gt;i&lt;/tt&gt; is &lt;tt&gt;i0&lt;/tt&gt;, we get &lt;tt&gt;j&lt;/tt&gt;
back and when &lt;tt&gt;i&lt;/tt&gt; is &lt;tt&gt;i1&lt;/tt&gt;, &lt;span class=inline-code&gt;i ∨ j&lt;/span&gt; collapses to &lt;tt&gt;i1&lt;/tt&gt;.
&lt;/p&gt;



&lt;p&gt;
The reader can check that &lt;span class=inline-code&gt;λ j → del x (dels e f j) (i ∨ j)&lt;/span&gt;
proves the equality &lt;span class=inline-code&gt;del x e i ++ f ≡ f&lt;/span&gt; and that it reduces
to the right expressions when &lt;tt&gt;i&lt;/tt&gt; is set to either of the interval&#39;s extremities.
Putting everything together, we get the following definition:
&lt;/p&gt;



&lt;p class=code&gt;dels : (e f : List⁰ A) → e ++ f ≡ f
dels []          f j = f
dels (x ∷ e)     f j = del x (dels e f j) j
dels (del x e i) f j = del x (dels e f j) (i ∨ j)
&lt;/p&gt;



&lt;a name=&quot;Conclusion&quot; /&gt;
&lt;h2&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Conclusion&quot;&gt;#&lt;/a&gt; Conclusion&lt;/h2&gt;



&lt;p&gt;
It took me about ten hours total to formalise the content of this post, most
of it spent on &lt;span class=inline-code&gt;dels&lt;/span&gt;. Once I understood the origin of
the side conditions one has to deal with in the cases involving
&lt;span class=inline-code&gt;del x e i&lt;/span&gt;, it finally clicked and things felt easier.
I hope this post makes the confluence imperative behind these side conditions
clear and really drills down the importance of computing them.
&lt;/p&gt;



&lt;p&gt;I would like to conclude this post by thanking
&lt;a href=&quot;http://cs.ru.nl/~nweide/&quot;&gt;Nils van der Weide&lt;/a&gt; and
&lt;a href=&quot;https://cs.ru.nl/~dfrumin/&quot;&gt;Dan Frumin&lt;/a&gt; for sharing my misery when
banging my head against these simple-looking problems as well as the insightful
discussions that ensued.
&lt;/p&gt;

&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;
Remember that an equality proof &lt;span class=inline-code&gt;x ≡ y&lt;/span&gt; in &lt;tt&gt;A&lt;/tt&gt; is a function
from the interval to &lt;tt&gt;A&lt;/tt&gt; which evaluates to &lt;span class=inline-code&gt;x&lt;/span&gt; at &lt;tt&gt;i0&lt;/tt&gt;
and &lt;span class=inline-code&gt;y&lt;/span&gt; at &lt;tt&gt;i1&lt;/tt&gt;. The proof &lt;span class=inline-code&gt;refl&lt;/span&gt;
of &lt;span class=inline-code&gt;x ≡ x&lt;/span&gt; corresponds to the constant function
&lt;span class=inline-code&gt;λ j → x&lt;/span&gt;.&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/first-cubical-experiment.html</guid><pubDate>Wed,  6 Mar 2019 13:37:00 UTC</pubDate></item><item><title>Instrumenting Total Parsers Written in agdarsec</title><link>http://gallais.github.io/blog/instrumenting-agdarsec.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Instrumenting Total Parsers Written in agdarsec&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.github.com/gallais/agdarsec&quot;&gt;agdarsec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gallais.github.io/agdarsec/&quot;&gt;documentation&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;


&lt;p id=chapo&gt;A common request I have received from (potential) users of my
library of total parser combinators is to add support for error reporting.
This is the story of adding such a machinery with minimal changes to the
combinators themselves.&lt;/p&gt;



&lt;a name=&quot;The(Idealized)TypeOfParsers&quot; /&gt;
&lt;h2&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#The(Idealized)TypeOfParsers&quot;&gt;#&lt;/a&gt; The (Idealized) Type of Parsers&lt;/h2&gt;



&lt;p&gt;The type of total parser combinators in
&lt;a href=&quot;https://github.com/gallais/agdarsec&quot;&gt;agdarsec&lt;/a&gt; is essentially a
fancy version of the classic Haskell type &lt;tt&gt;Parser a = String -&gt; [(String, a)]&lt;/tt&gt;.
The added complexity has two goals: to enforce totality and to give the
user more configuration options.&lt;/p&gt;



&lt;a name=&quot;ParametersOfTheParser.&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#ParametersOfTheParser.&quot;&gt;#&lt;/a&gt; Parameters of the Parser.&lt;/h3&gt;



&lt;p&gt;If the support for totality is baked in the representation
&lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt;, the configuration
options are granted by a set of parameters.&lt;/p&gt;



&lt;p class=code&gt;record Parameters : Set₁ where
  field
    Tok  : Set
    Toks : ℕ → Set
    M    : Set → Set
&lt;/p&gt;



&lt;p&gt;These parameters allow the user to specify a type of tokens &lt;tt&gt;Tok&lt;/tt&gt; the
parser is working on (for instance &lt;tt&gt;Char&lt;/tt&gt;), the type of the sized input
&lt;tt&gt;Toks&lt;/tt&gt; (typically something like &lt;tt&gt;Vec Tok&lt;/tt&gt;) and a monad &lt;tt&gt;M&lt;/tt&gt;.
The fact that the input is sized is essential for proving termination but is
largely irrelevant from the end-user&#39;s point of view. In effect the parser type
is morally equivalent to &lt;tt&gt;Parser a = Toks → M (a, Toks)&lt;/tt&gt; where the size
of the &lt;tt&gt;Toks&lt;/tt&gt; in the output is smaller than that of the one in the input.&lt;/p&gt;



&lt;p&gt;These definitions are already enough to define a wealth of parser combinators
ranging from conjunction, disjunction, left or right associated chains, etc. all
relying on the properties of &lt;tt&gt;M&lt;/tt&gt; (e.g. &lt;tt&gt;Alternative M&lt;/tt&gt; gives us the
ability to defined the disjunction combinator) to realise the expected behaviour.
For unambiguous grammars a simple &lt;tt&gt;Maybe&lt;/tt&gt;-based solution worsk really well.&lt;/p&gt;




&lt;p&gt;However by using &lt;tt&gt;Maybe&lt;/tt&gt; as our monad, whenever a parse fails the user
does not get any information about the failure. It makes debugging the parser (or
the expression being parsed) quite hard. This is where instrumentation comes in.&lt;/p&gt;




&lt;a name=&quot;InstrumentingAParser&quot; /&gt;
&lt;h2&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#InstrumentingAParser&quot;&gt;#&lt;/a&gt; Instrumenting a Parser&lt;/h2&gt;



&lt;p&gt;Most of the instrumentation can be done by picking a more appropriate stack of
monad transformers for &lt;tt&gt;M&lt;/tt&gt;. Keeping track of the position of the parser in
the original source file is the one thing that needs to be hard-wired by extending
the set of &lt;tt&gt;Parameters&lt;/tt&gt; of a &lt;tt&gt;Parser&lt;/tt&gt;. We add one new field:
&lt;tt&gt;recordToken&lt;/tt&gt; which is to be used &lt;i&gt;every&lt;/i&gt; time a token is read
from the input.&lt;/p&gt;



&lt;p class=code&gt;record Parameters : Set₁ where
  field
  (...)
    recordToken : Tok → M ⊤
&lt;/p&gt;



&lt;p&gt;The only change to the combinators in the library is in &lt;tt&gt;anyToken&lt;/tt&gt;,
the function which grabs the first token on the input (if it exists). It now
performs an extra operation before returning the grabbed value: it uses our
new &lt;tt&gt;recordToken&lt;/tt&gt; to remember the what was obtained.&lt;/p&gt;



&lt;a name=&quot;PositionTracking&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#PositionTracking&quot;&gt;#&lt;/a&gt; Position Tracking&lt;/h3&gt;



&lt;p&gt;Now that we record every token read from the input, we can start tracking
the current position in the source file. This can be used to associate a
position to each nodes of the Abstract Syntax Tree our parser produces
which is useful if we are for instance writing a compiler and want to be
able to report precise errors to users further down the line. We model
positions with two natural numbers corresponding to the line and character
offset respectively.&lt;/p&gt;



&lt;p class=code&gt;record Position : Set where
  field line   : ℕ
        offset : ℕ
&lt;/p&gt;



&lt;p&gt;Each character yields an action on positions: if it is a newline character
then we increment the line count and reset the offset one; otherwise we simply
increment the offset.&lt;/p&gt;



&lt;p class=code&gt;next : Char → Position → Position
next c p = if c == &#39;\n&#39;
  then record { line = suc (line p) ; offset = 0 }
  else record p { offset = suc (offset p) }
&lt;/p&gt;



&lt;p&gt;By using a &lt;tt&gt;StateT Position&lt;/tt&gt; transformer in our monad stack and
making sure that &lt;tt&gt;recordToken&lt;/tt&gt; updates the state by calling &lt;tt&gt;next&lt;/tt&gt;,
we now have extended character-based parsers to be position-aware.&lt;/p&gt;



&lt;p&gt;Not only can this be used to produce ASTs recording the source file positions
corresponding to each of their nodes, it also allows us to report parsing errors
more accurately by returning the position at the point of failure.&lt;/p&gt;



&lt;a name=&quot;DistinguishingSoftAndHardFailures&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#DistinguishingSoftAndHardFailures&quot;&gt;#&lt;/a&gt; Distinguishing Soft and Hard Failures&lt;/h3&gt;



&lt;p&gt;Simply using &lt;tt&gt;StateT Position (Position ⊎_)&lt;/tt&gt; as our monad does not
quite yield the behaviour we expect. If a parser cannot succeed on a source file,
it will always return as its position at the time of failure the one corresponding
to the failure in the rightmost path in our grammar. Indeed at each disjunction,
a failure in the left branch is recovered from by trying the right branch. However
this is often not what we want.&lt;/p&gt;



&lt;p&gt;For instance if we were to parse numbers written in either binary or hexadecimal
format, we could describe the parser as a disjunction between a parser for strings
of the form &lt;tt&gt;0b[01]+&lt;/tt&gt; and one for strings of the form &lt;tt&gt;0x[0-9A-F]+&lt;/tt&gt;.
For the input &quot;0b0000002&quot; the parser would:
&lt;ul&gt;&lt;li&gt; take the first branch and fail upon finding &#39;2&#39;&lt;/li&gt;
&lt;li&gt; backtrack to the disjunction&lt;/li&gt;
&lt;li&gt; take the second branch and fail upon finding &#39;b&#39;&lt;/li&gt;
&lt;li&gt; finish with an error reporting failure at the position of &#39;b&#39;&lt;/li&gt;&lt;/ul&gt;

Ideally we would like to bypass completely the second branch because having read &quot;0b&quot;,
we know that it can only fail. And we would like the error location to be that of &#39;2&#39;,
not of &#39;b&#39; because we feel like it&#39;s a fairer assessment of what the problem is.&lt;/p&gt;



&lt;p&gt;In other words: after having read a disambiguating token we sometimes want to
&lt;i&gt;commit&lt;/i&gt; to one branch of the disjunction, ignoring the alternatives.
We can do this by distinguishing soft failures (from which we can recover) from
hard failures (which are fatal).&lt;/p&gt;



&lt;p class=code&gt;data Result (A : Set) : Set where
  HardFail : Error → Result A
  SoftFail : Error → Result A
  Value    : A → Result A
&lt;/p&gt;



&lt;p&gt;The &lt;tt&gt;Alternative&lt;/tt&gt; instance for &lt;tt&gt;Result&lt;/tt&gt; is similar to that of
&lt;tt&gt;A ⊎_&lt;/tt&gt;: if the first computation has failed then we try the second one.
The only difference here is that we only try the other branch if we are facing
a &lt;i&gt;soft&lt;/i&gt; failure. Otherwise we propagate the error.&lt;/p&gt;



&lt;p class=code&gt;_∣_ : ∀ {A} → Result A → Result A → Result A
ma₁ ∣ ma₂ = case ma₁ of λ where
  (SoftFail _) → ma₂
  r            → r
&lt;/p&gt;



&lt;p&gt;This distinction between soft and hard failures gives us the ability to
&lt;tt&gt;commit&lt;/tt&gt; to one branch by turning &lt;i&gt;soft&lt;/i&gt; failures into
&lt;i&gt;hard&lt;/i&gt; ones.&lt;/p&gt;



&lt;p class=code&gt;commit : ∀ {A} → Result A → Result A
commit ma = case ma of λ where
  (SoftFail e) → HardFail e
  r            → r
&lt;/p&gt;



&lt;p&gt;This &lt;tt&gt;Result&lt;/tt&gt; type, the associated alternative instance and the use
of &lt;tt&gt;commit&lt;/tt&gt; bring two benefits to the table:
&lt;ul&gt;&lt;li&gt; the parser finishes faster when it fails because it ignores all the
       alternative branches&lt;/li&gt;
&lt;li&gt; the parser returns a more relevant error to the end-user rather than
       the one found in the last of the alternatives&lt;/li&gt;&lt;/ul&gt;
&lt;/p&gt;



&lt;p&gt;It is important to note that we get all of this without having to modify
the parser combinators; the setup is generic enough that end-users can drastically
alter a parser&#39;s behaviour and the amount of information it returns simply by
switching to a different monad stack. We can still think of alternatives such
as trying the second branch of the disjunction and in case it also fails use
a heuristics to decide which error to propagate.&lt;/p&gt;



&lt;a name=&quot;Conclusion&quot; /&gt;
&lt;h2&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Conclusion&quot;&gt;#&lt;/a&gt; Conclusion&lt;/h2&gt;



&lt;p&gt;We have seen how to add instrumentation to parsers written using total
parser combinators by changing the one combinator which pulls tokens directly
from the input and picking an appropriate monad stack. You can see these
design decisions in use in the STLC parser in
&lt;a href=&quot;https://github.com/gallais/agdarky/blob/aca1ccd76bdb341e7cba03c26a5e233935cf1306/src/stlc/Parse.agda#L62&quot;&gt;agdarky&lt;/a&gt;,
a project bringing together some of my libraries to write software entirely
in Agda.&lt;/p&gt;



&lt;a name=&quot;Acknowledgements&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Acknowledgements&quot;&gt;#&lt;/a&gt; Acknowledgements&lt;/h3&gt;



&lt;p&gt;This work would not have been possible without discussions with
&lt;a href=&quot;https://github.com/clayrat&quot;&gt;@clayrat&lt;/a&gt; on the
design, implementation and testing of the instrumentation of agdarsec and
their port of the changes to the Idris version of the library
(&lt;a href=&quot;https://github.com/gallais/idris-tparsec&quot;&gt;idris-tparsec&lt;/a&gt;).
&lt;/p&gt;

&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;For more details, read the &lt;a href=&quot;https://gallais.github.io/pdf/agdarsec18.pdf&quot;&gt;paper&lt;/a&gt;
discussing the first version of the library.&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/instrumenting-agdarsec.html</guid><pubDate>Fri, 13 Jul 2018 13:37:00 UTC</pubDate></item><item><title>Three Tricks to make Termination Obvious</title><link>http://gallais.github.io/blog/termination-tricks.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Three Tricks to make Termination Obvious&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html#prettier&quot;&gt;Wadler&#39;s Prettier Printer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/gallais/potpourri/tree/master/agda/prettier&quot;&gt;Prettier Printer in Agda&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;



&lt;p id=chapo&gt;Two weeks ago I spent some time implementing Wadler&#39;s
&quot;Prettier Printer&quot;. The implementation is fairly straightforward
except for three functions that are not seen as terminating. Here
are the three tricks that made them go through.&lt;/p&gt;



&lt;p&gt;Wadler&#39;s paper introduces a &lt;span class=inline-code&gt;Doc&lt;/span&gt; datatype
abstractly representing documents in terms of raw strings, indentation,
newlines, concatenation but also alternatives of subdocuments. Semantically,
alternatives are used to offer two different layouts of the same underlying
content. Various functions manipulate these documents; they may introduce
alternatives when it&#39;s too early to make a decision or get rid of them e.g.
once the maximum width of the final document is known.&lt;/p&gt;



&lt;a name=&quot;UsingVecRatherThanList&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#UsingVecRatherThanList&quot;&gt;#&lt;/a&gt; Using Vec rather than List&lt;/h3&gt;



&lt;p&gt;The first problem shows up with the &lt;span class=inline-code&gt;fill&lt;/span&gt;
function which turns a list of documents into a document by trying to
fill the lines as much as possible. If the list is less than one
element long, the strategy to adopt is evident. In case it&#39;s longer,
the algorithm calls &lt;span class=inline-code&gt;flatten&lt;/span&gt; to collapse
documents onto one line and offers two alternatives: the one where
they have been made to fit and another one where a newline has
been inserted.&lt;/p&gt;



&lt;p class=code&gt;fill :: [Doc] -&gt; Doc
...
fill (x:y:zs) = (flatten x &lt;+&gt; fill (flatten y : zs))
                :&lt;|&gt;
                (x &amp;lt;/&amp;gt; fill (y : zs))
&lt;/p&gt;



&lt;p&gt;The issue here is that &lt;span class=inline-code&gt;flatten y : zs&lt;/span&gt; is
not a subterm of &lt;span class=inline-code&gt;x:y:zs&lt;/span&gt; which makes the
recursive call to &lt;span class=inline-code&gt;fill&lt;/span&gt; look illegal. The
right notion of smaller here is not &quot;strict subterm&quot; but rather
&quot;smaller length&quot;. This can be fixed by simply changing the type of
the function to &lt;span class=inline-code&gt;∀ {n} → Vec Doc n → Doc&lt;/span&gt; thus
making the termination obviously structural: if the length of
&lt;span class=inline-code&gt;x:y:zs&lt;/span&gt; is &lt;span class=inline-code&gt;suc (suc n)&lt;/span&gt;
then the length of &lt;span class=inline-code&gt;flatten y : zs&lt;/span&gt; is
&lt;span class=inline-code&gt;suc n&lt;/span&gt;, a strict subterm!&lt;/p&gt;



&lt;p&gt;The code is kept the same but the type has an extra invariant
built in (which is threaded via implicit arguments) and that makes
the termination checker happy. We can recover a top-level function
with &lt;span class=inline-code&gt;fill&lt;/span&gt;&#39;s type by pre-composing our
replacement for it with &lt;span class=inline-code&gt;Data.Vec.fromList&lt;/span&gt;.&lt;/p&gt;



&lt;a name=&quot;CPS-transformAlgorithmsUsingQueuesToStoreFutureWork&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#CPS-transformAlgorithmsUsingQueuesToStoreFutureWork&quot;&gt;#&lt;/a&gt; CPS-transform algorithms using queues to store future work&lt;/h3&gt;



&lt;p&gt;In Wadler&#39;s paper, a function &lt;span class=inline-code&gt;best&lt;/span&gt; is in
charge of picking the most tightly-packed display form of a document
a certain width can handle. It calls an auxiliary function
&lt;span class=inline-code&gt;be&lt;/span&gt; which takes as arguments the width, the
number of characters already inserted on the current line and a LIFO
of documents (together with their respective indentation levels) that
still have to be displayed.&lt;/p&gt;



&lt;p&gt;During a typical run of the function, sub-structures get pushed
on the stack and later on recursive calls are performed on them.
However when that happens, we have lost the connection with the
super-structure justifying that the call is indeed on a smaller
argument and thus valid. Here is part of the code demonstrating
the issue:&lt;/p&gt;



&lt;p class=code&gt;be :: Int -&gt; Int -&gt; [(Int, Doc)] -&gt; Doc
...
be w k ((i,NIL):z)     = be w k z
be w k ((i,x :&lt;&gt; y):z) = be w k ((i,x):(i,y):z)
...
&lt;/p&gt;



&lt;p&gt;The trick here is to perform the recursive calls when the
evidence justifying them is available but to only use their
results later on. In other word: replace future arguments
with the continuation associated to them. This forces us to
slightly change the type of the function: rather than working
with a stack of &lt;span class=inline-code&gt;(Int, Doc)&lt;/span&gt; and
inspecting its head, we work with a focused
&lt;span class=inline-code&gt;Int&lt;/span&gt; and &lt;span class=inline-code&gt;Doc&lt;/span&gt;
and a continuation &lt;span class=inline-code&gt;Int -&gt; Doc&lt;/span&gt; which,
provided a number of characters already inserted on the current
line will yield the document corresponding to the rest of the
computation. The two lines we saw earlier on have now become
&lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt;:&lt;/p&gt;



&lt;p class=code&gt;be : ℕ → ℕ → ℕ → Doc → (ℕ → Doc) → Doc
...
be w k i NIL       ds = ds k
be w k i (d :&lt;&gt; e) ds = be w k i d $ λ k → be w k i e ds
...
&lt;/p&gt;



&lt;p&gt;For &lt;a href=&quot;https://github.com/gallais/potpourri/blob/master/agda/poc/CPS-Termination.agda&quot;&gt;
a more self-contained example&lt;/a&gt;, I have implemented a binary
tree traversal using the same trick to assemble a list of all its
leaves. The resulting algorithm corresponds to using a difference
list to collect all the leaves.&lt;/p&gt;



&lt;a name=&quot;UseSized-typesToMakeHigher-orderFunctionsUsable&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#UseSized-typesToMakeHigher-orderFunctionsUsable&quot;&gt;#&lt;/a&gt; Use sized-types to make higher-order functions usable&lt;/h3&gt;



&lt;p&gt;Last but not least, one of the examples of Wadler&#39;s library
in action is the definition of a pretty printer for a deep
embedding of XML. The XML trees are represented by:&lt;/p&gt;



&lt;p class=code&gt;data XML = Elt String [Att] [XML]
         | Txt String
data Att = Att String String&lt;/p&gt;



&lt;p&gt;The function &lt;span class=inline-code&gt;showXMLs&lt;/span&gt; is used to neatly
display the tree. In one of its clauses, it perform recursive calls
on the subtrees via a higher-order function &lt;span class=inline-code&gt;showFill&lt;/span&gt;
which Agda has issues seeing as terminating:&lt;/p&gt;



&lt;p class=code&gt;showFill :: (a -&gt; [Doc]) -&gt; [a] -&gt; Doc
showFill f [] = nil
showFill f xs = bracket &quot;&quot; (fill (concat (map f xs))) &quot;&quot;

showXMLs :: XML -&gt; [Doc]
...
showXMLs (Elt n a c)  = [text &quot;&lt;&quot; &lt;&gt; showTag n a &lt;&gt; text &quot;&gt;&quot; &lt;&gt;
                        showFill showXMLs c &lt;&gt;
                        text &quot;&amp;lt;/&quot; &lt;&gt; text n &lt;&gt; text &quot;&gt;&quot;]
...&lt;/p&gt;



&lt;p&gt;A common trick in this type of situation is to mutually define
&lt;span class=inline-code&gt;showXMLs&lt;/span&gt; and an inlined version of the
partially applied function &lt;span class=inline-code&gt;showFill showXMLs&lt;/span&gt;.
However this code duplication is rather annoying.
It turns out that we can, just like in our first example, save the day
by slightly changing the types of the structures and functions at hand.
This time we&#39;ll add implicit &lt;span class=inline-code&gt;Size&lt;/span&gt; information
&lt;a id=&quot;reftop2&quot; href=&quot;#refbot2&quot;&gt;[2]&lt;/a&gt; to the definition of
&lt;span class=inline-code&gt;XML&lt;/span&gt; and &lt;span class=inline-code&gt;showXMLs&lt;/span&gt;.
&lt;/p&gt;



&lt;p class=code&gt;data XML : {i : Size} → Set where
  Elt : ∀ {i} → String → List Attribute → List (XML {i}) → XML {↑ i}
  Txt : ∀ {i} → String → XML {i}

showXMLs : ∀ {i} → XML {i} → List Doc
...
&lt;/p&gt;



&lt;p&gt;When we don&#39;t explicitly specify the &lt;span class=inline-code&gt;Size&lt;/span&gt;,
it gets defaulted to infinity which means that by default the indexed
type will behave like its non-indexed counterpart. However we can get
the full benefit of sized types whenever we do mention the index.&lt;/p&gt;



&lt;p&gt;By making explicit reference to the tree&#39;s size in the type of
&lt;span class=inline-code&gt;showXMLs&lt;/span&gt;, we get the termination checker
to accept its definition as valid. Indeed, when matching on the
constructor &lt;span class=inline-code&gt;Elt&lt;/span&gt;, the implicit size argument
is &lt;span class=inline-code&gt;↑ i&lt;/span&gt; for some &lt;span class=inline-code&gt;i&lt;/span&gt;
(cf. &lt;span class=inline-code&gt;Elt&lt;/span&gt;&#39;s return type) and in the recursive
occurence passed to &lt;span class=inline-code&gt;showFill&lt;/span&gt;, it has become
&lt;span class=inline-code&gt;i&lt;/span&gt; which is strictly smaller.&lt;/p&gt;




&lt;a name=&quot;Conclusion&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Conclusion&quot;&gt;#&lt;/a&gt; Conclusion&lt;/h3&gt;



&lt;p&gt;What I assumed to be a simple matter of closely following
Wadler&#39;s paper turned out to be a nice exercise in convincing
the termination checker whilst staying true to the original
algorithm. In each one of these three examples we have managed
to avoid both the sledgehammer that is
&lt;a href=&quot;http://gallium.inria.fr/blog/bove-reloaded/&quot;&gt;well-founded
recursion&lt;/a&gt; and code duplication by using either type-level
tricks or a &lt;a href=&quot;http://dl.acm.org/citation.cfm?id=178053&quot;&gt;CPS
transformation&lt;/a&gt;.
&lt;/p&gt;


&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;Here we are actually using &lt;span class=inline-code&gt;ℕ&lt;/span&gt;
rather than &lt;span class=inline-code&gt;Int&lt;/span&gt; because these values
are always positive anyways so we might as well say so in the
type!&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot2&quot; href=&quot;#reftop2&quot;&gt;[2]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;For more on sized and dependent types, cf. Andreas Abel&#39;s
&lt;a href=&quot;http://www2.tcs.ifi.lmu.de/~abel/par10.pdf&quot;&gt;MiniAgda: Integrating
Sized and Dependent Types&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/termination-tricks.html</guid><pubDate>Thu, 24 Nov 2016 13:37:00 UTC</pubDate></item><item><title>Parametrised Modules: (ab)using lambda-lifting</title><link>http://gallais.github.io/blog/lambda-lifting.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Parametrised Modules: (ab)using lambda-lifting&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://gist.github.com/gallais/0b3a50e12542f455c010&quot;&gt;Self-contained gist&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;


&lt;p id=chapo&gt;Lately, I have been working quite a bit with
&lt;a href=&quot;https://github.com/gallais/type-scope-semantics&quot;&gt;an abstract notion
of Semantics&lt;/a&gt; defined as a set of combinators all packed in a
record. Doing so, I have come to enjoy the flexibility provided by
parameterised modules to define operations generically over such a
Semantics. In this blog post, I want to show how this pattern can be
used to tidy up some definitions.&lt;/p&gt;



&lt;a name=&quot;Introduction:ScopeAndLambdaLifting&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Introduction:ScopeAndLambdaLifting&quot;&gt;#&lt;/a&gt; Introduction: Scope and lambda lifting&lt;/h3&gt;



&lt;p&gt;A module declaration in Agda can be parameterised by a telescope of
arguments. These variables are then made available to the user across
the whole body of the module in a manner reminiscent of Coq&#39;s
&lt;a href=&quot;https://coq.inria.fr/distrib/8.4pl6/refman/Reference-Manual004.html#sec77&quot;&gt;Sections&lt;/a&gt;.
The most bare-bones example I could come up with is an &lt;span class=inline-code&gt;Identity&lt;/span&gt;
module parameterised by &lt;span class=inline-code&gt;A&lt;/span&gt;, a &lt;span class=inline-code&gt;Set&lt;/span&gt;, and defining the
identity function for &lt;span class=inline-code&gt;A&lt;/span&gt;. This definition is accepted without an
out of scope error being raised because, inside the module, the context
is extended with &lt;span class=inline-code&gt;A : Set&lt;/span&gt;.&lt;/p&gt;



&lt;p class=code&gt;module Identity (A : Set) where

  identity : A → A
  identity = λ x → x
&lt;/p&gt;



&lt;p&gt;Once we leave the module, the type of &lt;span class=inline-code&gt;identity&lt;/span&gt; as it is
written down does not make sense anymore because &lt;span class=inline-code&gt;A&lt;/span&gt;&#39;s scope
was only extending as far as the module was. The process of taking
such a definition and altering it so that it makes sense even outside
of &lt;span class=inline-code&gt;Identity&lt;/span&gt; is called
&lt;a href=&quot;https://en.wikipedia.org/wiki/Lambda_lifting&quot;&gt;lambda-lifting&lt;/a&gt;.
It consists in prepending the telescope of arguments the module was
parameterised with

&lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt;

to the type and body of the various defined symbols it contains. We can
check that &lt;span class=inline-code&gt;Identity.identity&lt;/span&gt;&#39;s type now includes an extra argument:
the type &lt;span class=inline-code&gt;A&lt;/span&gt;. Outside the &lt;span class=inline-code&gt;Identity&lt;/span&gt; module, it is effectively
the polymorphic identity

&lt;a id=&quot;reftop2&quot; href=&quot;#refbot2&quot;&gt;[2]&lt;/a&gt;

(the highlighted part is the one generated by the lambda-lifting):&lt;/p&gt;



&lt;p class=code&gt;check : Identity.identity ∈ &lt;span class=highlight&gt;∀ A →&lt;/span&gt; A → A
check = indeed
&lt;/p&gt;




&lt;a name=&quot;AMoreComplexExample&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#AMoreComplexExample&quot;&gt;#&lt;/a&gt; A more complex example&lt;/h3&gt;



&lt;p&gt;In my experience these parameterised modules are particularly helpful
when you need to make the content of a record, passed as an argument,
available to the type and body of a defined symbol. To keep things simple,
I decided to use one of the most basic constructs in the standard library&#39;s
&lt;span class=inline-code&gt;Algebra&lt;/span&gt;: a &lt;span class=inline-code&gt;RawMonoid&lt;/span&gt;. If you have one such beast, then
you can aggregate values by using the monoid&#39;s binary operation and
&lt;a href=&quot;https://www.youtube.com/watch?v=We90tGh1z3g#t=11m29s&quot;&gt;people do
that in &lt;i&gt;real&lt;/i&gt; software&lt;/a&gt;.&lt;/p&gt;



&lt;p&gt;This module is called &lt;span class=inline-code&gt;Reduce&lt;/span&gt;, it is parameterised by a &lt;span class=inline-code&gt;RawMonoid&lt;/span&gt;

&lt;a id=&quot;reftop3&quot; href=&quot;#refbot3&quot;&gt;[3]&lt;/a&gt;

and it implements &lt;span class=inline-code&gt;aggregate&lt;/span&gt;, a function which collapses a list
of values down to a single one. Here it is crucial for us to be able
to bring the fields of the &lt;span class=inline-code&gt;RawMonoid mon&lt;/span&gt; in scope for the
whole definition: &lt;span class=inline-code&gt;Carrier&lt;/span&gt;, &lt;span class=inline-code&gt;_∙_&lt;/span&gt; and &lt;span class=inline-code&gt;ε&lt;/span&gt; are
all packed up in that record.&lt;/p&gt;



&lt;p class=code&gt;module Reduce {c ℓ : Level} (mon : RawMonoid c ℓ) where

  open RawMonoid mon

  aggregate : List Carrier → Carrier
  aggregate = foldr _∙_ ε&lt;/p&gt;



&lt;p&gt;It would of course be possible to write an equivalent function without
using such a module: it all amounts to lambda-lifting the definition by
hand. However no matter the approach we choose (bringing the same constants
in scope or projecting the values out of the record), the definitions
become far less readable:&lt;/p&gt;



&lt;p class=code&gt;aggregate′ : {c ℓ : Level} (mon : RawMonoid c ℓ) →
             let open RawMonoid mon in List Carrier → Carrier
aggregate′ mon = let open RawMonoid mon in foldr _∙_ ε

aggregate′′ : {c ℓ : Level} (mon : RawMonoid c ℓ) →
              List (RawMonoid.Carrier mon) → RawMonoid.Carrier mon
aggregate′′ mon = foldr (RawMonoid._∙_ mon) (RawMonoid.ε mon)
&lt;/p&gt;



&lt;p&gt;We can now use &lt;span class=inline-code&gt;aggregate&lt;/span&gt; with an extra argument (the
&lt;span class=inline-code&gt;RawMonoid&lt;/span&gt; in question). Assuming we have &lt;span class=inline-code&gt;ℕ+&lt;/span&gt; and
&lt;span class=inline-code&gt;ℕ*&lt;/span&gt; (respectively the additive and multiplicative monoids over
the natural numbers) and a function &lt;span class=inline-code&gt;[_⋯_]&lt;/span&gt; generating a range
of natural numbers, we can write some test about computations involving
&lt;span class=inline-code&gt;aggregate&lt;/span&gt;:&lt;/p&gt;



&lt;p class=code&gt;test-aggregate : Reduce.aggregate ℕ+ [ 1 ⋯ 5 ] ≡ 15
               ∧ Reduce.aggregate ℕ* [ 1 ⋯ 5 ] ≡ 120
test-aggregate = refl , refl&lt;/p&gt;



&lt;p&gt;One last thing I like to do in this sort of situation, especially
when defining what could be considered a semantics, is to anticipate
the lambda-lifting and define an infix operator which uses a double
turnstile (⊨) to separate the specific theory used from the
(parametrically defined) computation it acts upon. Here this would mean
adding the following line &lt;b&gt;inside&lt;/b&gt; the module &lt;span class=inline-code&gt;Reduce&lt;/span&gt;:&lt;/p&gt;



&lt;p class=code&gt;  _⊨reduce_ = aggregate&lt;/p&gt;



&lt;p&gt;&lt;span class=inline-code&gt;_⊨reduce_&lt;/span&gt; is supposed to take two arguments but, inside
&lt;span class=inline-code&gt;Reduce&lt;/span&gt;, &lt;span class=inline-code&gt;aggregate&lt;/span&gt; only takes one. This weird mismatch
is solved when we leave the module and the &lt;span class=inline-code&gt;RawMonoid&lt;/span&gt; argument
is lambda-lifted. We can now write &lt;span class=inline-code&gt;A ⊨reduce xs&lt;/span&gt; to mean that we use
the monoid &lt;span class=inline-code&gt;A&lt;/span&gt; to give a meaning to the phrase &quot;reduce xs&quot;.
The same tests as before hold but I find the type more readable:&lt;/p&gt;



&lt;p class=code&gt;test-reduce : ℕ+ ⊨reduce [ 1 ⋯ 5 ] ≡ 15
            ∧ ℕ* ⊨reduce [ 1 ⋯ 5 ] ≡ 120
test-reduce = refl , refl&lt;/p&gt;


&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;
This is only a first approximation. It is
naturally possible to have a slightly more subtle approach and to only
prepend the variables which appear free in the type and body of the
defined symbols together will all the ones they themselves depend on
(and so on recursively). In other words, to only use the smallest,
dependency-closed sub-context containing the variables free in the
defined symbol&#39;s type and body.
&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot2&quot; href=&quot;#reftop2&quot;&gt;[2]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;
&lt;p&gt;Here we write &lt;span class=inline-code&gt;a ∈ A&lt;/span&gt; to mean that &lt;span class=inline-code&gt;a&lt;/span&gt; has type &lt;span class=inline-code&gt;A&lt;/span&gt;.
This notion can be defined using a simple indexed family which looks a
lot like propositional equality: because of the way the only constructor
&lt;span class=inline-code&gt;indeed&lt;/span&gt; is defined, if &lt;span class=inline-code&gt;a ∈ A&lt;/span&gt; is inhabited then &lt;span class=inline-code&gt;A&lt;/span&gt;
can only ever be &lt;span class=inline-code&gt;a&lt;/span&gt;&#39;s type:&lt;/p&gt;

&lt;p class=code&gt;data _∈_ {ℓ : Level} {A : Set ℓ} (a : A) : (B : Set ℓ) → Set where
  indeed : a ∈ A
&lt;/p&gt;
&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot3&quot; href=&quot;#reftop3&quot;&gt;[3]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;
In the standard library, a &lt;span class=inline-code&gt;Monoid&lt;/span&gt; is a &lt;span class=inline-code&gt;RawMonoid&lt;/span&gt;
plus some laws. Here we do not care about the proofs that &lt;span class=inline-code&gt;_∙_&lt;/span&gt;
is associative and &lt;span class=inline-code&gt;ε&lt;/span&gt; a neutral element for it. It goes without
saying that in a general-purpose library, it would be more interesting
to work on a &lt;span class=inline-code&gt;Monoid&lt;/span&gt; and prove &lt;span class=inline-code&gt;aggregate&lt;/span&gt;&#39;s properties
(e.g. that it is a monoid homomorphism).
&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/lambda-lifting.html</guid><pubDate>Wed,  6 Jan 2016 13:37:00 UTC</pubDate></item><item><title>Canonical Structures in Agda using REWRITE</title><link>http://gallais.github.io/blog/canonical-structures-REWRITE.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Canonical Structures in Agda using REWRITE&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/agda/agda/blob/0716021c904186ca806a34fe110ae0fca4a3dd70/src/full/Agda/TypeChecking/Rewriting.hs#L5L42&quot;&gt;REWRITE&#39;s documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/gallais/438793c5ed7988826b9b&quot;&gt;Agda Gist&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;



&lt;p id=chapo&gt;Last week I talked about &lt;a href=&quot;canonical-structures-currying&quot;&gt;currying
using Coq&#39;s Canonical Structures&lt;/a&gt;. This got me thinking about how to
get something similar working in Agda. It turns out that the recently
introduced &lt;span class=inline-code&gt;REWRITE&lt;/span&gt; pragma is just what is needed to replicate
this use case.&lt;/p&gt;



&lt;p&gt;Let us start with a quick reminder of the problem at hand: the goal is
to be able to write a &lt;span class=inline-code&gt;map&lt;/span&gt; function working on lists and automatically
currying its argument as much as possible. Why you ask? Well because we
really don&#39;t want to have to define &lt;span class=inline-code&gt;map_tuple&lt;/span&gt;, &lt;span class=inline-code&gt;map_triple&lt;/span&gt;
and so on with all the possible nestings imaginable.&lt;/p&gt;



&lt;a name=&quot;section0&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section0&quot;&gt;#&lt;/a&gt; The definition of &lt;span class=inline-code&gt;Curry&lt;/span&gt; and various instances&lt;/h3&gt;



&lt;p&gt;The first thing to do is to introduce a record &lt;span class=inline-code&gt;Curry&lt;/span&gt; describing
the sort of domains we may curry. You may recognise the structure we used
in &lt;a href=&quot;canonical-structures-currying&quot;&gt;the previous blog post&lt;/a&gt;: this
record packs a domain (&lt;span class=inline-code&gt;dom&lt;/span&gt;), a type constructor (&lt;span class=inline-code&gt;cur&lt;/span&gt;)
and a proof (&lt;span class=inline-code&gt;prf&lt;/span&gt;) that for any codomain &lt;span class=inline-code&gt;cod&lt;/span&gt;, one may turn
an element of type &lt;span class=inline-code&gt;cur cod&lt;/span&gt; into a function from &lt;span class=inline-code&gt;dom&lt;/span&gt; to
&lt;span class=inline-code&gt;cod&lt;/span&gt;.&lt;/p&gt;



&lt;p class=code&gt;record Curry : Set₁ where
  field
    dom : Set
    cur : Set → Set
    prf : (cod : Set) (f : cur cod) → dom → cod&lt;/p&gt;



&lt;p&gt;The next step is to define instances of &lt;span class=inline-code&gt;Curry&lt;/span&gt;. The most
obvious instance is probably the one doing nothing: for any domain
&lt;span class=inline-code&gt;A&lt;/span&gt;, we can define &lt;span class=inline-code&gt;cur&lt;/span&gt; to be the function which
associates &lt;span class=inline-code&gt;A → cod&lt;/span&gt; to each codomain &lt;span class=inline-code&gt;cod&lt;/span&gt;. The
proof that one can turn &lt;span class=inline-code&gt;A → cod&lt;/span&gt; into &lt;span class=inline-code&gt;cur cod&lt;/span&gt;
is then trivial.&lt;/p&gt;




&lt;p class=code&gt;curryDefault : (A : Set) → Curry
curryDefault A =
  record { dom = A
         ; cur = λ cod → A → cod
         ; prf = λ cod → id
         }&lt;/p&gt;



&lt;p&gt;We then explain how to combine two instances of &lt;span class=inline-code&gt;Curry&lt;/span&gt; by
taking, as domain, the product of their respective domains. The
definitions of &lt;span class=inline-code&gt;cur&lt;/span&gt; and &lt;span class=inline-code&gt;prf&lt;/span&gt; become a bit more involved
but should be understandable.&lt;/p&gt;



&lt;p class=code&gt;curryPair : (A B : Curry) → Curry
curryPair A B =
  record { dom = dom A × dom B
         ; cur = λ cod → cur A (cur B cod)
         ; prf = λ cod f p → prf B cod
                            (prf A (cur B cod)
                             f (fst p)) (snd p)
         }&lt;/p&gt;




&lt;a name=&quot;section1&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section1&quot;&gt;#&lt;/a&gt; Using &lt;span class=inline-code&gt;REWRITE&lt;/span&gt; to guide the typechecker&lt;/h3&gt;



&lt;p&gt;A &lt;a href=&quot;https://github.com/agda/agda/blob/0716021c904186ca806a34fe110ae0fca4a3dd70/src/full/Agda/TypeChecking/Rewriting.hs#L5L42&quot;&gt;&lt;span class=inline-code&gt;REWRITE&lt;/span&gt; pragma&lt;/a&gt;
has recently been introduced to allow the user to define a binary relation
characterizing equations the typechecker should internalise. The primary
goal is, as far as I know, to allow homotopy type theorists to have a bit
of fun with an equality that looks like it computes. But there&#39;s no
reason to leave it to them! Obviously, this is an unsafe feature and if
you are not careful when picking your rewrite rules, you will get the
typechecker into an infinite loop. It happened to me a couple of times
whilst drafting this program.&lt;/p&gt;



&lt;p&gt;The sole purpose of the &lt;span class=inline-code&gt;Canonical&lt;/span&gt; relation we introduce is
to guide the rewriting process. As such, we don&#39;t care about its
implementation and can simply postulate it. We also introduce a
&lt;span class=inline-code&gt;Target&lt;/span&gt; precisely identifying the candidates for rewriting
in order to avoid to send Agda into an infinite loop by reapplying
the default rule over and over again.&lt;/p&gt;



&lt;p class=code&gt;postulate
  Canonical        : (A B : Curry) → Set
  Target           : (A : Set) → Curry
&lt;/p&gt;



&lt;p&gt;We can then define two rewrite rules based on our previous combinators.
The order in which they are introduced matters and that is why we start
with the one dealing with pairs so that we only ever use &lt;span class=inline-code&gt;curryDefault&lt;/span&gt;
when reaching a base type or a type variable.&lt;/p&gt;



&lt;p class=code&gt;postulate
  CanonicalProd    : {A B : Set} → Canonical (Target (A × B)) (curryPair (Target A) (Target B))
  CanonicalDefault : {A : Set} →   Canonical (Target A) (curryDefault A)
&lt;/p&gt;



&lt;p&gt;Finally, we use the appropriate pragmas to declare &lt;span class=inline-code&gt;Canonical&lt;/span&gt;
as the relation characterizing the equations which should be internalised
and tell Agda to use &lt;span class=inline-code&gt;CanonicalProd&lt;/span&gt; and &lt;span class=inline-code&gt;CanonicalDefault&lt;/span&gt;
as rewrite rules.&lt;/p&gt;



&lt;p class=code&gt;{-# BUILTIN REWRITE Canonical #-}
{-# REWRITE CanonicalProd     #-}
{-# REWRITE CanonicalDefault  #-}&lt;/p&gt;



&lt;p&gt;It is now time to define our generic mapping function. Just like last
time, it is preferable to defined a &lt;span class=inline-code&gt;flippedMap&lt;/span&gt; in order to fire
the easy constraint &lt;span class=inline-code&gt;List (Target A)&lt;/span&gt; first. We define
&lt;span class=inline-code&gt;flippedMap&lt;/span&gt; with a domain &lt;span class=inline-code&gt;A&lt;/span&gt; which we now to be &lt;span class=inline-code&gt;Curry&lt;/span&gt;
and use its &lt;span class=inline-code&gt;prf&lt;/span&gt; field to transport the function passed as an
argument.&lt;/p&gt;



&lt;p class=code&gt;flippedMap : {A : Curry} {B : Set} (xs : List (dom A)) (f : cur A B)  → List B
flippedMap {A} xs f = map (prf A _ f) xs&lt;/p&gt;



&lt;p&gt;We then introduce a slight variation on &lt;span class=inline-code&gt;flippedMap&lt;/span&gt; which
turns its argument into a &lt;span class=inline-code&gt;Target&lt;/span&gt;. This is a great occasion
to add a bit of syntactic sugar putting the arguments back in their
right order. We choose to stick to applicative style combinators and use
&lt;span class=inline-code&gt;_⟨$⟩_&lt;/span&gt;.&lt;/p&gt;



&lt;p class=code&gt;flippedMap&#39; : {A B : Set} (xs : List (dom (Target A))) (f : cur (Target A) B)  → List B
flippedMap&#39; {A} = flippedMap {Target A}

syntax flippedMap&#39; xs f = f ⟨$⟩ xs&lt;/p&gt;



&lt;p&gt;We can now have a look at a couple of small examples. It should be
noted that our typechecking-time magic does not break anything: these examples
still compute! Indeed normalising &lt;span class=inline-code&gt;example₁&lt;/span&gt; yields &lt;span class=inline-code&gt;3 ∷ 5 ∷ []&lt;/span&gt;
whilst doing the same for &lt;span class=inline-code&gt;example₂&lt;/span&gt; gives us &lt;span class=inline-code&gt;17 ∷ 30 ∷ []&lt;/span&gt;.&lt;/p&gt;



&lt;p class=code&gt;example₁ : List ℕ
example₁ = _+_ ⟨$⟩ (1 , 2) ∷ (2 , 3) ∷ []

example₂ : List ℕ
example₂ = (λ k l m n → k * l + m * n)
           ⟨$⟩ ((1 , 2) , (3 , 5)) ∷ ((2 , 3) , (4 , 6)) ∷ []&lt;/p&gt;

</description><guid isPermaLink="true">http://gallais.github.io/blog/canonical-structures-REWRITE.html</guid><pubDate>Wed,  5 Aug 2015 13:37:00 UTC</pubDate></item><item><title>Currying using Canonical Structures</title><link>http://gallais.github.io/blog/canonical-structures-currying.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Currying using Canonical Structures&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://hal.inria.fr/hal-00816703&quot;&gt;Mahboubi &amp; Tassi&#39;s paper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/gallais/d3dae1f7d5fe9e9d5ab5&quot;&gt;Universe for Currying&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gist.github.com/gallais/8923120a41396bb21615&quot;&gt;Canonical Structures for Currying&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;



&lt;p id=chapo&gt;I have been meaning to have a look at Canonical Structures at
some point since Beta Ziliani told me about 4 years ago that all the Ltac
magic I was doing to reify expressions could be handed over to the inference
engine. Yesterday I was finally given a simple opportunity to play with
them. Here&#39;s the result.&lt;/p&gt;



&lt;p&gt;Whilst reading &lt;a href=&quot;http://coq-blog.clarus.me/simple-unit-testing-in-coq.html&quot;&gt;a
completely unrelated blog post&lt;/a&gt; about unit testing in Coq, I stumbled
upon a series of almost identical functions named &lt;span class=inline-code&gt;List.map_pair&lt;/span&gt;,
&lt;span class=inline-code&gt;List.map_triple&lt;/span&gt; and &lt;span class=inline-code&gt;List.map_quad&lt;/span&gt;. I thought to myself
that, surely, it should be possible in a language with type-level computations
to do away with the sort of &lt;a href=&quot;http://hackage.haskell.org/package/base-4.8.1.0/docs/Data-List.html#v:zipWith3&quot;&gt;monstrosities&lt;/a&gt;
one can sometime find in Haskell libraries.
Introducing &lt;a href=&quot;https://gist.github.com/gallais/d3dae1f7d5fe9e9d5ab5&quot;&gt;a
Universe closed under products&lt;/a&gt; can indeed allow the definition of
generic (un)currying functions. However we are still left with the burden
of reifying the domain of the function we want to curry. Annoying.&lt;/p&gt;



&lt;a name=&quot;section0&quot; /&gt;
&lt;h2&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section0&quot;&gt;#&lt;/a&gt; &lt;center&gt;Canonical Structures to the rescue!&lt;/center&gt;&lt;/h2&gt;



&lt;p&gt;That is when Canonical Structures come to the rescue: they are a way
to give hints to the unification algorithm when it faces a problem of the
shape &lt;span class=inline-code&gt;project ?x ~ term&lt;/span&gt; where &lt;span class=inline-code&gt;project&lt;/span&gt; is a projection
out of a record, &lt;span class=inline-code&gt;?x&lt;/span&gt; is a unification variable and &lt;span class=inline-code&gt;term&lt;/span&gt;
is... a term. Because this unification step can lead to new ones, we
effectively have a way to encode a prolog-like proof search. And we are
going to use it to generate the right sort of currying.&lt;/p&gt;



&lt;a name=&quot;TheClassOfDomainsWhichCanBeCurried&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#TheClassOfDomainsWhichCanBeCurried&quot;&gt;#&lt;/a&gt; The Class of domains which can be curried&lt;/h3&gt;



&lt;p&gt;This whole development is following quite closely the really good
introduction &lt;a href=&quot;https://hal.inria.fr/hal-00816703&quot;&gt;Canonical Structures
for the working Coq user&lt;/a&gt;. We start by defining a module which
contains first and foremost a Record &lt;span class=inline-code&gt;class&lt;/span&gt; indexed by a domain
&lt;span class=inline-code&gt;Dom&lt;/span&gt; and a type constructor &lt;span class=inline-code&gt;Curr&lt;/span&gt; such that &lt;span class=inline-code&gt;Curr a&lt;/span&gt;
is a curried version of the function space &lt;span class=inline-code&gt;Dom -&gt; a&lt;/span&gt; as witnessed
by the &lt;span class=inline-code&gt;Fun&lt;/span&gt; stored in the record.&lt;/p&gt;



&lt;p class=code&gt;Module Currying.
  Record class (Dom : Type) (Curr : Type -&gt; Type) :=
         Class { Fun : forall cod, Curr cod -&gt; (Dom -&gt; cod) }.
&lt;/p&gt;



&lt;p&gt;We then define a structure called &lt;span class=inline-code&gt;type&lt;/span&gt; packing together
a &lt;span class=inline-code&gt;Dom&lt;/span&gt;, a &lt;span class=inline-code&gt;Curr&lt;/span&gt; and the &lt;span class=inline-code&gt;class Dom Curr&lt;/span&gt; evidence
that they are related.&lt;/p&gt;



&lt;p class=code&gt;  Structure type := Pack { dom      : Type
                         ; curr     : Type -&gt; Type
                         ; class_of : class dom curr }.
&lt;/p&gt;



&lt;p&gt;Now, remember that canonical structures are used to give hints to the
unification algorithm when facing &lt;span class=inline-code&gt;project ?x ~ term&lt;/span&gt; problems.
Having this &lt;span class=inline-code&gt;type&lt;/span&gt; structure will allow us to generate
&lt;span class=inline-code&gt;dom ?x ~ something&lt;/span&gt; unification problems which means that the
unification algorithm will be able to infer from the shape of the domain
what its curried version is. In order to trigger these unification problems,
we are defining a special version of &lt;span class=inline-code&gt;map&lt;/span&gt; on &lt;span class=inline-code&gt;list&lt;/span&gt;:&lt;/p&gt;



&lt;p class=code&gt;  Definition flippedmap (Curry : type) :
    forall cod, list (dom Curry) -&gt; curr Curry cod -&gt; list cod.
    refine (let &#39;Pack _ _ (Class fc) := Curry
            in fun cod xs f =&gt; List.map _ xs) ; apply fc, f.
  Defined.
&lt;/p&gt;



&lt;p&gt;Multiple things are going on here. First we define the function
interactively because we have some nasty type-level dependencies and
this post is not about dependent matching in Coq. Second we implemented
&lt;span class=inline-code&gt;flippedmap&lt;/span&gt; rather than &lt;span class=inline-code&gt;map&lt;/span&gt; because taking the function
first would create a unification problem &lt;span class=inline-code&gt;curr ?x ~ [some function type]&lt;/span&gt;
which is obviously harder to resolve than &lt;span class=inline-code&gt;list (dom ?x) ~ list ([some type])&lt;/span&gt;.&lt;/p&gt;



&lt;p&gt;We can introduce a notation in order to recover the usual arguments
order. We then close our &lt;span class=inline-code&gt;Currying&lt;/span&gt; module and bring the notation
into scope.&lt;/p&gt;



&lt;p class=code&gt;  Module theory.
  Notation &quot;f &lt;$&gt; xs&quot; := (flippedmap xs f) (at level 70).
  End theory.
End Currying.

Import Currying.theory.&lt;/p&gt;



&lt;a name=&quot;section1&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section1&quot;&gt;#&lt;/a&gt; The Canonical Structures associated to &lt;span class=inline-code&gt;Currying.type&lt;/span&gt;&lt;/h3&gt;



&lt;p&gt;Now that our interface has been defined, it is time to populate it
with canonical instances. The first one simply states that given two
domains we know how to curry, we can explain how to curry their product.
The nesting &lt;span class=inline-code&gt;fun cod =&gt; Currying.curr c1 (Currying.curr c2 cod)&lt;/span&gt;
is chosen so that arguments are kept in the right order.&lt;/p&gt;



&lt;p class=code&gt;Definition pair_curry (c1 c2 : Currying.type) :
           forall cod, Currying.curr c1 (Currying.curr c2 cod) -&gt;
                       (Currying.dom c1 * Currying.dom c2) -&gt; cod.
  intros cod f (a, b).
  apply c2 ; [| exact b].
  apply c1 ; [| exact a].
  exact f.
Defined.

Canonical Structure CurryingPair (c1 : Currying.type) (c2 : Currying.type) : Currying.type :=
  Currying.Pack (Currying.dom c1 * Currying.dom c2)
                (fun cod =&gt; Currying.curr c1 (Currying.curr c2 cod))
                (Currying.Class (pair_curry c1 c2)).
&lt;/p&gt;



&lt;p&gt;That&#39;s all well and good except that we don&#39;t know yet how to deal
with base types. Should we add an instance for each one of them? And
what about type variables? It turns out that we can rely on the fact
that these hints are tried in the order they are declared in and introduce
a defaulting instance which does not do anything as witnessed by its
&lt;span class=inline-code&gt;Fun&lt;/span&gt; component which is simply the identity.&lt;/p&gt;



&lt;p class=code&gt;Canonical Structure failsafe (a : Type) : Currying.type :=
  Currying.Pack a (fun cod =&gt; a -&gt; cod) (Currying.Class (fun _ f =&gt; f)).&lt;/p&gt;




&lt;a name=&quot;ConcludingExamples&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#ConcludingExamples&quot;&gt;#&lt;/a&gt; Concluding Examples&lt;/h3&gt;



&lt;p&gt;Thanks to the canonical structures, we can effortlessly recover the
functions &lt;span class=inline-code&gt;List.map_pair&lt;/span&gt;, &lt;span class=inline-code&gt;List.map_triple&lt;/span&gt; and
&lt;span class=inline-code&gt;List.map_quad&lt;/span&gt; I mentioned earlier:&lt;/p&gt;



&lt;p class=code&gt;Definition map_pair {A B C} (f : A -&gt; B -&gt; C) (l : list (A * B)) : list C := f &lt;$&gt; l.
Definition map_triple {A B C D} (f : A -&gt; B -&gt; C -&gt; D) (l : list (A * B * C)) : list D := f &lt;$&gt; l.
Definition map_quad {A B C D E} (f : A -&gt; B -&gt; C -&gt; D -&gt; E) (l : list (A * B * C * D)) : list E := f &lt;$&gt; l.&lt;/p&gt;



&lt;p&gt;But we can also deal with arbitrary nesting patterns:&lt;/p&gt;



&lt;p class=code&gt;Definition map_nestedpairs {A B C D E} (f : A -&gt; B -&gt; C -&gt; D -&gt; E) (l : list ((A * B) * (C * D))) : list E := f &lt;$&gt; l.
&lt;/p&gt;

</description><guid isPermaLink="true">http://gallais.github.io/blog/canonical-structures-currying.html</guid><pubDate>Tue, 28 Jul 2015 13:37:00 UTC</pubDate></item><item><title>Resource Aware Contexts and Proof Search for ILL</title><link>http://gallais.github.io/blog/linear-proof-search.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Resource Aware Contexts and Proof Search for ILL&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/gallais/proof-search-ILLWiL&quot;&gt;Github repository&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://gallais.github.io/proof-search-ILLWiL/&quot;&gt;Papers &amp; coloured Agda&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;


&lt;p id=chapo&gt;Type theory is expressive enough that one can implement
&lt;i&gt;certified&lt;/i&gt; proof search algorithms not only telling us whether
something is provable or not but providing us with a derivation
which is statically known to be correct. However this comes at a
price: the original systems are usually formulated in a hand-wavy
way which is quite strongly incompatible with a formal treatment
thus forcing us to find alternative presentations.&lt;/p&gt;



&lt;p&gt;In this blog post, I&#39;ll try to highlight the main points of
&lt;a href=&quot;http://gallais.github.io/proof-search-ILLWiL/&quot;&gt;the draft&lt;/a&gt;
Conor and I wrote in December / January. We will see how to
reformulate a fragment of Intuitionistic Linear Logic in order to
make the implementation of a certified proof search algorithm
tractable.&lt;/p&gt;




&lt;p&gt;Before starting, I would like to point out that Liam O&#39;Connor wrote
a &lt;a href=&quot;http://liamoc.net/posts/2014-01-01-context-split.html&quot;&gt;very nice
blog post&lt;/a&gt; showcasing the usual ℕ-index definition of untyped
lambda terms as well as introducing an elegant syntax for &quot;linear&quot;
&lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt; proof terms &lt;a id=&quot;reftop2&quot; href=&quot;#refbot2&quot;&gt;[2]&lt;/a&gt;. It has the same underlying idea:
massaging the original definitions can lead to a calculus more suited
for a mechanised approach.&lt;/p&gt;



&lt;a name=&quot;TheILLFragmentWeAreInterestedIn.&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#TheILLFragmentWeAreInterestedIn.&quot;&gt;#&lt;/a&gt; The ILL fragment we are interested in.&lt;/h3&gt;



&lt;p&gt;We are dealing with the fragment equipped with base types, tensor
and par. The linearity restriction makes the right introduction rule
for tensor awkward to use: the prover has to guess how to partition
the context in two in a way that will let her discharge the subgoals.
In the setting of &lt;i&gt;certified automated proof search&lt;/i&gt;, the context
is represented as a snoc list of assumptions rather than a multiset
thus leading us to write the rule the following way:&lt;/p&gt;



&lt;p class=code&gt; Γ ≡ Δ ⋈ E    Δ ⊢ σ    E ⊢ τ
------------------------------ ⊗ʳ
            Γ ⊢ σ `⊗ τ&lt;/p&gt;



&lt;p&gt;Here, &lt;span class=inline-code&gt;Γ ≡ Δ ⋈ E&lt;/span&gt; means that &lt;span class=inline-code&gt;Γ&lt;/span&gt; is obtained by
interleaving &lt;span class=inline-code&gt;Δ&lt;/span&gt; and &lt;span class=inline-code&gt;E&lt;/span&gt; which, if we read the rule
bottom-up, precisely correspond to the idea of finding the right
partition when applying &lt;span class=inline-code&gt;⊗ʳ&lt;/span&gt;. But we really do not want to
have to generate &lt;i&gt;all&lt;/i&gt; partitions and test them one after the
other. This leads us to our first maxim:&lt;/p&gt;



&lt;a name=&quot;IfIt&#39;sTooComplicated,SolveAMoreGeneralProblem!&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#IfIt&#39;sTooComplicated,SolveAMoreGeneralProblem!&quot;&gt;#&lt;/a&gt; If it&#39;s too complicated, solve a more general problem!&lt;/h3&gt;



&lt;p&gt;It turns out that we can craft a calculus more general than linear
logic which will not force the logician to guess partitions all the
time. I must confess that I have lied by omission up to this point:
this whole enterprise was not started by the mere will to formalize
proof search for linear logic. It has been spawned by Conor coming in
the office and presenting ideas about type theories with
&lt;a href=&quot;https://pigworker.wordpress.com/2014/12/31/worlds/&quot;&gt;world annotations&lt;/a&gt;.
One of his ideas was that typing a term might impact the context (e.g.
by changing the world an assumption lives in) which implies automatically
that one needs both an &quot;input&quot; as well as an &quot;output&quot; context in the
typing relation. We end up with something like that:&lt;/p&gt;



&lt;p class=code&gt;Γ ⊢ t : T ⊣ Δ&lt;/p&gt;



&lt;p&gt;I rapidly had the feeling that a similar formulation could be very
useful in certifying proof search for linear logic and started
experimenting with the idea. Instead of guessing how to partition
the context, we could think of the calculus as describing the idea
that we start with a pool of resources available, prove a formula
and end up with the leftovers not used in that proof. Proof search
becomes resource consumption.&lt;/p&gt;



&lt;p&gt;The tensor introduction rule would simply use the whole context
to try to prove the first subgoal, get back whatever is leftover and
use that as an input to attempt solving the second one. After some
investigations, this is the introduction rules I came up with for our
new sequent calculus generalising linear logic:&lt;/p&gt;



&lt;p class=code&gt;  Γ ∋ k ∈ Δ              Γ ⊢ σ ⊣ Δ    Δ ⊢ τ ⊣ E               Γ ⊢ σ ⊣ Δ₁    Γ ⊢ τ ⊣ Δ₂    E ≡ Δ₁ ⊙ Δ₂
------------ κ          ------------------------ ⊗           ----------------------------------------- &amp;
Γ ⊢ `κ k ⊣ Δ                 Γ ⊢ σ `⊗ τ ⊣ E                               Γ ⊢ σ `&amp; τ ⊣ E&lt;/p&gt;



&lt;p&gt;The case of atomic propositions is defined in terms of an auxiliary
relation &lt;span class=inline-code&gt;_∋_∈_&lt;/span&gt; describing how variable lookup consumes a
resource from the context. In the tensor case, we have arbitrarily
decided that proof search will start on the first subgoal and thread
the contexts as expected. The par one is slightly more subtle: we use
the same input to explore both subgoals in parallel but have to make
sure that the outputs are synchronized i.e. that the assumptions used
by both subproofs are the same.&lt;/p&gt;



&lt;p&gt;The intuition describing contexts as multisets of resources,
and specifically the output one as leftovers, begets the following
soudness theorem showing the connection with good ol&#39; IMLL: if we
remove whatever was a leftover from the input context then we can
recover a derivation in ILL.&lt;/p&gt;



&lt;p class=code&gt;soundness : Γ ⊢ σ ⊣ Δ → Γ ─ Δ ⊢ σ&lt;/p&gt;



&lt;p&gt;Defining this difference operator is however quite hard: we have
nothing (apart from the derivation &lt;span class=inline-code&gt;Γ ⊢ σ ⊣ Δ&lt;/span&gt; itself) telling
us that &lt;span class=inline-code&gt;Δ&lt;/span&gt; is indeed a sub-multiset of &lt;span class=inline-code&gt;Γ&lt;/span&gt;! This new
obstacle teaches us our second principle:&lt;/p&gt;



&lt;a name=&quot;NeverDitchTheStructureYouMightWantToUseLaterOn!&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#NeverDitchTheStructureYouMightWantToUseLaterOn!&quot;&gt;#&lt;/a&gt; Never ditch the structure you might want to use later on!&lt;/h3&gt;



&lt;p&gt;It is hard for us to define &lt;span class=inline-code&gt;Γ ─ Δ&lt;/span&gt; because we don&#39;t know
how &lt;span class=inline-code&gt;Γ&lt;/span&gt; relates to &lt;span class=inline-code&gt;Δ&lt;/span&gt;. But this can be dealt with by
introducing the notion of consumption annotation: instead of defining
the sequent calculus over contexts of assumptions, we can define it
over &lt;span class=inline-code&gt;Usage&lt;/span&gt;s of &lt;i&gt;a given context&lt;/i&gt;. Consumption via the
axiom rule turns available resources into consumed ones but, most
importantly, it preserves the structure of it all!&lt;/p&gt;



&lt;p&gt;A &lt;span class=inline-code&gt;Usage&lt;/span&gt; of a context &lt;span class=inline-code&gt;γ&lt;/span&gt; is defined in a pointwise
manner saying whether each assumption is an available resource or an
already used one. A variable lookup will merely turn a previously
available assumption into a used one. And checking that two outputs
are synchronized now amounts to making sure that the &lt;span class=inline-code&gt;Usage&lt;/span&gt;s
agree in a pointwise manner! The relation corresponding to &lt;span class=inline-code&gt;Usage&lt;/span&gt;
differences is also defined in a pointwise manner and we can prove that
&lt;span class=inline-code&gt;Γ ⊢ σ ⊣ Δ&lt;/span&gt; being derivable implies that there is a difference
&lt;span class=inline-code&gt;E&lt;/span&gt; such that &lt;span class=inline-code&gt;E ⊢ σ&lt;/span&gt;.&lt;/p&gt;



&lt;p&gt;The last unresolved problem is the way we are going to deal with
left rules. The left rule for par is a direct loss of information:
we move from having &lt;span class=inline-code&gt;A &amp; B&lt;/span&gt; as an assumption to either one
of the subformula. If the goal we are trying to prove is
&lt;span class=inline-code&gt;B &amp; A&lt;/span&gt; then applying a left rule too early will lead us to
a dead end. The one for tensor is typically needed before using a
right introduction rule for tensor itself: the two subformulas of
the assumptions may be used in different subproofs e.g. when proving
&lt;span class=inline-code&gt;A ⊗ B&lt;/span&gt; with &lt;span class=inline-code&gt;A ⊗ B&lt;/span&gt; in the context. But it could
also be applied earlier on without any dramatic consequences.
Hence our last slogan:&lt;/p&gt;



&lt;a name=&quot;NeverDoMoreThanYouNeedTo!&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#NeverDoMoreThanYouNeedTo!&quot;&gt;#&lt;/a&gt; Never do more than you need to!&lt;/h3&gt;



&lt;p&gt;In an approach reminiscent of focusing &lt;a id=&quot;reftop3&quot; href=&quot;#refbot3&quot;&gt;[3]&lt;/a&gt;, we realize that we do not need to have left rules. Indeed,
it is possible to formulate the notion of usage in a way that completely
frees us from having to deal with them: rather than having a binary
notion of usage for assumptions, we can have a more subtle one describing
how an assumption may have been partially used so far. For example,
we may write &lt;span class=inline-code&gt;[ A ]⊗ B&lt;/span&gt; to mean that &lt;span class=inline-code&gt;A&lt;/span&gt; is entirely
available whilst &lt;span class=inline-code&gt;B&lt;/span&gt; is partially used. A careful analysis
of a derivation in the more general calculus will allow us to
insert left rules wherever needed.&lt;/p&gt;



&lt;a name=&quot;Conclusion&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Conclusion&quot;&gt;#&lt;/a&gt; Conclusion&lt;/h3&gt;



&lt;p&gt;I hope I have managed to sum up quite clearly the 3 main take home
messages of our paper. They are not really specific to linear logic
itself but rather good practices when working in a formal system. If
you&#39;d like more details about the ILL setup itself, don&#39;t hesitate to
&lt;a href=&quot;http://gallais.github.io/proof-search-ILLWiL/&quot;&gt;have a read&lt;/a&gt;.
We show there that our generalised calculus enjoys a notion of weakening
(you can always throw in more resources in the input context, they&#39;ll
just be returned to you untouched in the output one!) and that it is
sound and complete with respect to derivability in ILL. We conclude
that the fragment is decidable and derive solvers for equations on a
commutative monoid as well as a more specialised one using Nisse&#39;s
&lt;a href=&quot;http://www.cse.chalmers.se/~nad/publications/danielsson-bag-equivalence.html&quot;&gt;
Bag Equivalence via a Proof-Relevant Membership Relation&lt;/a&gt;.&lt;/p&gt;

&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;Liam&#39;s system is inspired by linear logic extended with
explicit contraction and weakening.&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot2&quot; href=&quot;#reftop2&quot;&gt;[2]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;I
was not aware of his work at the time I wrote the procedure presented
here and did not pay much attention to the way I formulated ILL because
the interesting part is elsewhere. A system closer to his would provide
a nicer interface though.&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot3&quot; href=&quot;#reftop3&quot;&gt;[3]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;See: Logic Programming
with Focusing Proofs in Linear Logic, by Jean-Marc Andreoli
(&lt;a href=&quot;http://www.citeulike.org/user/gallais/article/5375157&quot;&gt;citeulike&lt;/a&gt;)
&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/linear-proof-search.html</guid><pubDate>Mon,  2 Mar 2015 13:37:00 UTC</pubDate></item><item><title>Ever considered using Travis?</title><link>http://gallais.github.io/blog/travis-builds.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Ever considered using Travis?&lt;/h1&gt;&lt;div class=bdocs&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://docs.travis-ci.com&quot;&gt;Travis: Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.travis-ci.com/user/encryption-keys&quot;&gt;Travis: Encrypting variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://docs.travis-ci.com/user/encrypting-files/&quot;&gt;Travis: Encrypting files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/settings/applications&quot;&gt;Github: Access tokens&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/andreafabrizi/Dropbox-Uploader/&quot;&gt;Dropbox: cli tool&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.dropbox.com/sh/yn8pr2jorbzsy2g/AABc445eZQIwnXqEuPody0pga?dl=0&quot;&gt;Travis-friendly Agda bins&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;/div&gt;



&lt;p id=chapo&gt;Over the Christmas break, I decided to play a bit with
&lt;a href=&quot;https://travis-ci.org&quot;&gt;Travis&lt;/a&gt;, a continuous integration
platform building, testing and deploying software. Here are the
various projects that benefited from it.&lt;/p&gt;



&lt;a name=&quot;BabySteps&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#BabySteps&quot;&gt;#&lt;/a&gt; Baby steps&lt;/h3&gt;



&lt;p&gt;The first thing I set out to do was run a test build of the
projects hosted on my &lt;a href=&quot;https://github.com/impega/vart&quot;&gt;vart&lt;/a&gt;
repository where, inspired by Jenn Schiffer&#39;s
&lt;a href=&quot;http://vart.institute&quot;&gt;var t;&lt;/a&gt; experiments, I try to write
programs which generate artsy things using haskell. Mondrian generates
and exports (using &lt;a href=&quot;http://hackage.haskell.org/package/JuicyPixels&quot;&gt;JuicyPixels&lt;/a&gt;)
images &lt;a href=&quot;/img/mondrian.png&quot;&gt;in this style&lt;/a&gt; whilst
&lt;a href=&quot;https://en.wikipedia.org/wiki/Exquisite_corpse&quot;&gt;ExquisiteCorpse&lt;/a&gt;
is pretty self-explanatory. Getting this to work
was as simple as registering on the travis website, flipping a switch
for this repo, &lt;a href=&quot;https://byorgey.wordpress.com/20100415/cabal-init&quot;&gt;
creating a .cabal file&lt;/a&gt; for each project and adding a
&lt;a href=&quot;https:github.com/impega/vart/blob/master/.travis.yml&quot;&gt;
really simple .travis.yml file&lt;/a&gt; to the tree.&lt;/p&gt;



&lt;a name=&quot;UsingGithubTokens&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#UsingGithubTokens&quot;&gt;#&lt;/a&gt; Using Github tokens&lt;/h3&gt;



&lt;p&gt;Building and testing is all fine and dandy until we want to produce
some &lt;i&gt;artefacts&lt;/i&gt; from the built software and share them. Well, one
solution to such a problem is to use personal access tokens on github
and simply host the content on &lt;a href=&quot;https://pages.github.com/&quot;&gt;Github
pages&lt;/a&gt;.&lt;/p&gt;



&lt;a name=&quot;section0&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section0&quot;&gt;#&lt;/a&gt; Building &lt;a href=&quot;http://gallais.org&quot;&gt;this very website&lt;/a&gt;&lt;/h4&gt;



&lt;p&gt;This website used to be hosted by &lt;a href=&quot;http://perso.ens-lyon.fr&quot;&gt;ENS Lyon&lt;/a&gt;
but, not being a student there anymore, it was finally taken down in October
2014. It used to be written in php which &lt;a href=&quot;https://personal.cis.strath.ac.uk/&quot;&gt;
our personal pages&#39; server&lt;/a&gt; does not support so I figured it was as
good an excuse as any to rewrite the whole thing from scratch.
I settled for &lt;a href=&quot;https://github.com/jaspervdj&quot;&gt;jaspervdj&lt;/a&gt;&#39;s
&lt;a href=&quot;http://jaspervdj.be/hakyll&quot;&gt;Hakyll&lt;/a&gt; mainly because it is
written in haskell and I figured I could extend it to meet my needs rather
easily. As it turned out, getting travis to build and deploy the pages
was probably the least painful step in the whole process; in comparison
figuring out how to parse &lt;a href=&quot;https://github.com/gallais/gallais.github.io/tree/source/src/Text/BBCode&quot;&gt;
the flavour of &lt;span class=inline-code&gt;BBCode&lt;/span&gt;&lt;/a&gt; I use for these posts was hell
&lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt;.&lt;/p&gt;



&lt;p&gt;The &lt;a href=&quot;https://github.com/gallais/gallais.github.io/blob/master/.travis.yml&quot;&gt;.travis.yml
file&lt;/a&gt; is sligtly more complicated this time given that I need to
push the generated html pages to the &lt;span class=inline-code&gt;master&lt;/span&gt; branch of the
repository. To do so, one needs to generate personal access tokens
&lt;a href=&quot;https://github.com/settings/applications&quot;&gt;on github&lt;/a&gt; and then
&lt;a href=&quot;http://docs.travis-ci.com/user/encryption-keys&quot;&gt;encrypt them using
&lt;span class=inline-code&gt;travis&lt;/span&gt;&lt;/a&gt;. If you look closely at the file, that&#39;s the
&lt;span class=inline-code&gt;${GH_TOKEN}&lt;/span&gt; I use when pushing.&lt;/p&gt;



&lt;a name=&quot;section1&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section1&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;http://impega.github.io/reciptacle&quot;&gt;Publishing recipes&lt;/a&gt; with a little bit of bash magic&lt;/h4&gt;



&lt;p&gt;As soon as I understood how to get it to work, I put together the
&lt;a href=&quot;http://impega.github.io/reciptacle&quot;&gt;reciptacle&lt;/a&gt; website. A
bunch of us, uni friends from Lyon, have been sharing recipes we
enjoy cooking on a github repository for quite a while. With a bit
of bash scripting magic, the markdown files are now turned into html
ones, are listed in an index and added to different categories based
on the #hashtags they contain.&lt;/p&gt;



&lt;p&gt;All of this was made possible by this relatively simple
&lt;a href=&quot;https://github.com/impega/reciptacle/blob/master/.travis.yml&quot;&gt;.travis.yml&lt;/a&gt;
file. I should add that the whole process has been made more secure by
&lt;a href=&quot;http://www.loria.fr/~hferee/index_en.html&quot;&gt;Hugo&lt;/a&gt; using
&lt;a href=&quot;http://hackage.haskell.org/package/ShellCheck&quot;&gt;ShellCheck&lt;/a&gt;,
yet another really cool haskell project, to detect typical caveats
in our various scripts.&lt;/p&gt;



&lt;a name=&quot;section2&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section2&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;https://agda.github.io/agda-stdlib/&quot;&gt;Documentation for Agda&#39;s
standard library&lt;/a&gt;&lt;/h4&gt;



&lt;p&gt;Once you know how to upload content to github pages, it is rather
easy to figure out how to generate and push the documentation produced
e.g. by Agda when typechecking a project. This is why we now have
travis generating the standard library&#39;s documentation.&lt;/p&gt;



&lt;a name=&quot;EncryptingDropboxCredentials&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#EncryptingDropboxCredentials&quot;&gt;#&lt;/a&gt; Encrypting Dropbox credentials&lt;/h3&gt;



&lt;p&gt;If a github repository is ideal to host text files, it is rather
different when you want to distribute binaries where you do not care
about the previous versions. This is where Dropbox comes into play
in this little series of experiments: &lt;a href=&quot;https://github.com/andreafabrizi&quot;&gt;
Andrea Fabrizi&lt;/a&gt;&#39;s &lt;a href=&quot;https://github.com/andreafabrizi/Dropbox-Uploader&quot;&gt;
Dropbox-Uploader&lt;/a&gt; makes interacting with Dropbox very easy! And
using travis&#39; hability to &lt;a href=&quot;http://docs.travis-ci.com/user/encrypting-files/&quot;&gt;
encrypt files&lt;/a&gt;, we can safely upload our credentials to a public
repository.&lt;/p&gt;



&lt;a name=&quot;BuildingAStatically-linkedAgdaExecutable&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#BuildingAStatically-linkedAgdaExecutable&quot;&gt;#&lt;/a&gt; Building a statically-linked Agda executable&lt;/h4&gt;



&lt;p&gt;The way the documentation for Agda&#39;s standard library was generated
by my first script was not very robust: we would fetch the current master
branch of Agda and compile it (which may fail) before starting the real
work. But why should the documentation generation fail if the master
branch does not compile at the precise time where the build was started?
Well, it should not. Why should we spend some time recompiling Agda
at every change in the standard library? Well, we should not.&lt;/p&gt;



&lt;p&gt;I could not rely on the ubuntu package as it was clearly too old
for the standard library which tends to rely on &quot;newly&quot; (as in &quot;in the
last few months&quot;) introduced features. The obvious solution was to,
somehow, get travis to generate a static binary when compiling and
testing Agda and upload it on Dropbox. This is the purpose of my
&lt;a href=&quot;https://github.com/gallais/agda/tree/build-binary&quot;&gt;&lt;span class=inline-code&gt;build-binary&lt;/span&gt;&lt;/a&gt;
branch.&lt;/p&gt;



&lt;p&gt;Compiling static haskell executables is not a process well documented
online. It is pretty hard to stay sane when facing stackoverflow answers
pointing you at a blog now defunct, toy examples not dealing with e.g.
data directories (hint: Agda has some!), and invalid information about
permission escalation in order to run some of the install as root
(typically: creating the data directories in /usr/share/).&lt;/p&gt;



&lt;p&gt;After quite a bit of poking around, I finally managed to find
&lt;a href=&quot;https://github.com/gallais/agda/commit/bb6fcc3fad3e4cf6a5b5ae4416a48cd5414e60ad
#diff-b771849a88d590a1da0b3a183b4f2be7&quot;&gt;the right set of flags&lt;/a&gt;
(at least for linux, it&#39;s not tested on windows). I could not fix the
permission escalation problem (yes, I have tried root-cmd) so I ended up
adopting a solution I am not proud of:
&lt;a href=&quot;https://github.com/gallais/agda/blob/build-binary/.travis.yml#L58&quot;&gt;
manually creating the directories&lt;/a&gt; I need with the permissions
I want. If someone knows &lt;i&gt;the right way&lt;/i&gt; to do it, please do share
&lt;a id=&quot;reftop2&quot; href=&quot;#refbot2&quot;&gt;[2]&lt;/a&gt;!&lt;/p&gt;



&lt;a name=&quot;GetTravisToBuildYourDrafts!&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#GetTravisToBuildYourDrafts!&quot;&gt;#&lt;/a&gt; Get Travis to build your drafts!&lt;/h3&gt;



&lt;p&gt;Once you have travis-compatible Agda executables lying around and a
draft paper which is actually a literate Agda file, there is one obvious
thing to do: get travis to typecheck your development, build your paper
and the documentation for the whole project and host all of this on
github pages. This is precisely what Conor and I have done with our
&lt;a href=&quot;http://gallais.github.io/proof-search-ILLWiL/&quot;&gt;Certified Proof
Search for Intuitionistic Linear Logic&lt;/a&gt; draft. This is surely
not the final answer to &lt;a href=&quot;http://math.andrej.com/2013/08/19/how-to-review-formalized-mathematics/&quot;&gt;
How to review formalized mathematics&lt;/a&gt; but it might be a step in
the right direction.&lt;/p&gt;



&lt;p&gt;To access the tarballs hosted on Dropbox using the command-line,
I have the impression that one needs my credentials. However they
are &lt;a href=&quot;https://www.dropbox.com/sh/yn8pr2jorbzsy2g/AABc445eZQIwnXqEuPody0pga?dl=0&quot;&gt;
available for all to download&lt;/a&gt; so there may be a way to automate
that. If you have suggestions with respect to alternative hosting
solutions making it easier for other people&#39;s scripts to pull the
tarballs, &lt;a href=&quot;/contact.html&quot;&gt;&lt;b&gt;please contact me&lt;/b&gt;&lt;/a&gt;!&lt;/p&gt;

&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;You should not conclude anything about &lt;span class=inline-code&gt;parsec&lt;/span&gt; from
that: I had no prior experience in parsing so I had a lot to learn
and spent quite some time trying various libraries and parser generators
before finally settling for &lt;span class=inline-code&gt;parsec&lt;/span&gt;. Which does the job as you
can see.&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot2&quot; href=&quot;#reftop2&quot;&gt;[2]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;A working travis build would be the best demonstration that
what you are suggesting is indeed the solution!&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/travis-builds.html</guid><pubDate>Wed, 11 Feb 2015 13:37:00 UTC</pubDate></item><item><title>Cyclic Lists, Purely</title><link>http://gallais.github.io/blog/cyclic-list-purely.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Cyclic Lists, Purely&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/gallais/potpourri/blob/master/haskell/cyclic/CyclicList.hs&quot;&gt;Haskell code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.citeulike.org/user/gallais/article/1244296&quot;&gt;Fegaras &amp; Sheard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.citeulike.org/user/gallais/article/8246712&quot;&gt;Ghani et al.&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;


&lt;p id=chapo&gt;In the paper
&lt;a href=&quot;http://www.citeulike.org/user/gallais/article/1244296&quot;&gt;
&lt;i&gt;Representing Cyclic Structures as Nested Datatypes&lt;/i&gt;&lt;/a&gt;,
the authors dismiss quite quickly the idea of encoding cyclic lists
by using a function space to represent the loop in favour of
(type-level) de Bruijn levels. I wanted to see how far one can go
with the more extensional approach whilst retaining good properties
(canonical forms, productivity, etc.). It turns out that the answer
is: &quot;quite far, really&quot;.&lt;/p&gt;



&lt;p&gt;The setup is pretty simple: we want to represent cyclic lists in
a purely functional language. A naïve solution would be to turn to
codata and use streams built using a fixpoint in Haskell. However,
representing the cycle with a material artefact will allow us to
analyze it (is it finite?), display it as a string by writing the
fixpoint down explicitly, make serialization trivial or transform
it by mapping a function, permuting the elements, or adding /
removing some of them from the cycle.&lt;/p&gt;



&lt;a name=&quot;FegarasAndSheard&#39;sSolution&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#FegarasAndSheard&#39;sSolution&quot;&gt;#&lt;/a&gt; Fegaras and Sheard&#39;s solution&lt;/h3&gt;



&lt;p&gt;Cyclic lists are represented using a mixed-variant datatype. On
top of the expected &lt;span class=inline-code&gt;CNil&lt;/span&gt; and &lt;span class=inline-code&gt;Cons&lt;/span&gt; shared with usual
lists, a &lt;span class=inline-code&gt;CRec&lt;/span&gt; constructor is provided. It declares a pointer
which may be used later on to represent that very node. It should be
noted that &lt;span class=inline-code&gt;CRec&lt;/span&gt; is &lt;span class=inline-code&gt;Cons&lt;/span&gt;-like in order to guarantee
that all cycles are productive.&lt;/p&gt;



&lt;p class=code&gt;data CList a = CNil
             | Cons a (CList a)
             | CRec a (CList a -&gt; CList a)&lt;/p&gt;



&lt;p&gt;This definition exploits the function space of the host language
to handle the pointer declaration in a sort of Higher Order
Abstract Syntax fashion. It makes giving a semantics for it in terms
of streams quite easy: one just needs to feed the function stored in
&lt;span class=inline-code&gt;CRec&lt;/span&gt; with the list itself.&lt;/p&gt;



&lt;p class=code&gt;toStream :: CList a -&gt; [a]
toStream CNil          = []
toStream (Cons x xs)   = x : toStream xs
toStream xs@(CRec x r) = x : toStream (r xs)&lt;/p&gt;



&lt;a name=&quot;TheLimitationsOfThisRepresentation&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#TheLimitationsOfThisRepresentation&quot;&gt;#&lt;/a&gt; The limitations of this representation&lt;/h3&gt;



&lt;p&gt;Now, this representation has multiple problems. They are pointed
out in Ghani et al. to justify their favouring of a more intensional
approach to cycle representation. Most of them relate to the fact
that it does not put enough restrictions on the ways one may use
the variable provided by the &lt;span class=inline-code&gt;CRec&lt;/span&gt; constructor. As a
consequence, the encoding lacks canonicity.&lt;/p&gt;



&lt;a name=&quot;ThereIsNoGuaranteeOnTheWayPointersAreUsed(ifAtAll)&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#ThereIsNoGuaranteeOnTheWayPointersAreUsed(ifAtAll)&quot;&gt;#&lt;/a&gt; There is no guarantee on the way pointers are used (if at all)&lt;/h3&gt;



&lt;p&gt;Given that the cycle is represented using a function space, it
is hard to detect whether the variable has been used at all, or if
it has been used whether it was in a proper way or not. So far
nothing prevents a list from pretending to be cyclic by introducing
a pointer it will never use:&lt;/p&gt;



&lt;p class=code&gt;finite = Cons 1 $ CRec 2 $ const CNil&lt;/p&gt;



&lt;p&gt;Or introduce multiple pointers only one of which is meant to be
declared whilst the other ones are &lt;span class=inline-code&gt;CRec&lt;/span&gt; cells misused as
&lt;span class=inline-code&gt;Cons&lt;/span&gt; ones. This leads to the possibility of different
representations of the same object:&lt;/p&gt;



&lt;p class=code&gt;fourTwos = Cons 4 $ CRec 2 id
arghTwos = CRec 4 $ const $ CRec 2 id&lt;/p&gt;



&lt;p&gt;Last but not least, these lists can also fail at being cyclic
because a list transformer has been used improperly in the body
of the cycle without being rejected by the typechecker:&lt;/p&gt;



&lt;p class=code&gt;nats = CRec 0 $ cmap (+1)&lt;/p&gt;



&lt;a name=&quot;UsefulFunctionsCannotBeWrittenWithoutUnfoldingTheCycle&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#UsefulFunctionsCannotBeWrittenWithoutUnfoldingTheCycle&quot;&gt;#&lt;/a&gt; Useful functions cannot be written without unfolding the
cycle&lt;/h3&gt;



&lt;p&gt;But there is more! Even if one is willing to excuse these
imperfections, it is hard to define basic functions without
unwinding the cycle. It is for instance impossible to map a
function across a list without unfoding it. Indeed, using a
&lt;span class=inline-code&gt;CRec&lt;/span&gt; constructor in the last case would provide us
with a &lt;span class=inline-code&gt;CList b&lt;/span&gt; element but &lt;span class=inline-code&gt;r&lt;/span&gt; expects a
&lt;span class=inline-code&gt;CList a&lt;/span&gt; one.&lt;/p&gt;



&lt;p class=code&gt;cmap :: (a -&gt; b) -&gt; CList a -&gt; CList b
cmap f CNil          = CNil
cmap f (Cons x xs)   = Cons (f x) $ cmap f xs
&lt;span class=bad&gt;cmap f xs@(CRec x r) = Cons (f x) $ cmap f (r xs)&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;At that point, the picture we have drawn is pretty grim and we
can understand why one may want to ditch the extensional approach
altogether. But it turns out that there is a solution to all of our
problems: the type system!&lt;/p&gt;



&lt;a name=&quot;CallingTheTypeSystemToTheRescue.&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#CallingTheTypeSystemToTheRescue.&quot;&gt;#&lt;/a&gt; Calling the type system to the rescue.&lt;/h3&gt;



&lt;p&gt;A few days before being confronted with this issue, I had read
the very interesting &lt;a href=&quot;https://tel.github.io/2014/07/15/mutable_algorithms_in_immutable_languages_part_3/&quot;&gt;account of the ST monad by Joseph Abrahamson&lt;/a&gt;
explaining how the implementation used rank 2 polymorphism to avoid
references escaping their environment. It was only natural to recycle
that knowledge in our case to avoid all the API abuses evoked in the
previous section. The new &lt;span class=inline-code&gt;CList&lt;/span&gt; type constructor takes two
arguments; the first one is the type of the elements it contains
whilst the second one is a phantom type used to enforce that the
constructor are only ever used in the way they were meant to.&lt;/p&gt;



&lt;p class=code&gt;data CList a b where
  CNil :: CList a Closed
  Cons :: a -&gt; CList a b -&gt; CList a b
  CRec :: a -&gt; (forall b. CList a b -&gt; CList a b) -&gt; CList a Closed&lt;/p&gt;



&lt;p&gt;&lt;span class=inline-code&gt;CRec&lt;/span&gt;&#39;s argument has to be polymorphic in the phantom
type which means that it may not use &lt;span class=inline-code&gt;CRec&lt;/span&gt; or &lt;span class=inline-code&gt;CNil&lt;/span&gt;
both of which fix the phantom type to &lt;span class=inline-code&gt;Closed&lt;/span&gt;. In effect,
it has to be a finite number of &lt;span class=inline-code&gt;Cons&lt;/span&gt; followed by the
variable provided. In other words, an element of type
&lt;span class=inline-code&gt;CList a Closed&lt;/span&gt; describes precisely a potentially cyclic
list &lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt;. Hence the following type alias:&lt;/p&gt;



&lt;p class=code&gt;data Closed = Closed
type List a = CList a Closed&lt;/p&gt;



&lt;p&gt;All the broken examples are now rightfully rejected by the type
system which detects that we are trying to conflate types which are
incompatible when we declare a pointer but forget to use it, when we
declare multiple ones, etc. That is already a nice change but we
are still facing a major challenge: writing functions such as
&lt;span class=inline-code&gt;map&lt;/span&gt; without unfolding the cycle. This is what Ghani et al.
write on that topic:&lt;/p&gt;



&lt;p class=quote&gt; &quot;Although cycles are explicit in this representation,
almost all functions manipulating cyclic structures will need to
unwind the cycles (based on the intuition that Rec means fix). The
reason is that, although, we can recognize cycles as structures of
the form Rec f, the argument f is a function and we cannot analyze
functions well&quot;.&lt;/p&gt;



&lt;p&gt;This was absolutely true in the situation they were facing. But
by exploiting the type system, we have managed to root out an
awful lot of unwanted constructs. To the point that we now know
for sure that there is &lt;i&gt;at most one&lt;/i&gt; &lt;span class=inline-code&gt;CRec&lt;/span&gt; constructor
in a &lt;span class=inline-code&gt;List a&lt;/span&gt;. This implies in particular that we can detect
where the pointer declared by a &lt;span class=inline-code&gt;CRec&lt;/span&gt; is used. Indeed, if
&lt;span class=inline-code&gt;xs&lt;/span&gt; is equal to &lt;span class=inline-code&gt;CRec x f&lt;/span&gt; then we know for sure that
&lt;span class=inline-code&gt;f xs&lt;/span&gt; will contain a &lt;span class=inline-code&gt;CRec&lt;/span&gt; and that it will be the
head constructor of &lt;span class=inline-code&gt;xs&lt;/span&gt; showing up where the pointer was
used.&lt;/p&gt;



&lt;p&gt;This means that we can actually build a &lt;span class=inline-code&gt;cfold&lt;/span&gt; function
which will not unwind the cycle unless we want it to. Let&#39;s start
by writing down the most general type for it. The two first arguments
corresponds to the usual &lt;span class=inline-code&gt;Cons&lt;/span&gt; and &lt;span class=inline-code&gt;CNil&lt;/span&gt; cases with
the right phantom types sprinkled where necessary. The third one
is the one dealing with cycles and it mimics really closely the type
of &lt;span class=inline-code&gt;CRec&lt;/span&gt;. The whole thing is implemented in terms of an
auxiliary function.&lt;/p&gt;



&lt;p class=code&gt;cfold :: forall a (b :: * -&gt; *).
         (forall ph. a -&gt; b ph -&gt; b ph) -&gt;
         b Closed -&gt;
         (a -&gt; (forall ph. b ph -&gt; b ph) -&gt; b Closed) -&gt;
         List a -&gt; b Closed
cfold c n r = goCRec&lt;/p&gt;



&lt;p&gt;This auxiliary function unfolds the list argument applying the
appropriate combinator to the constructor&#39;s arguments and the
the induction hypothesis. As its name &lt;span class=inline-code&gt;goCRec&lt;/span&gt; suggests, it
traverses the &lt;span class=inline-code&gt;CRec&lt;/span&gt; constructor before handing over the rest
of the work to &lt;span class=inline-code&gt;stopCRec&lt;/span&gt;.&lt;/p&gt;



&lt;p class=code&gt;goCRec :: forall ph. CList a ph -&gt; b ph
goCRec CNil          = n
goCRec (Cons x xs)   = c x $ goCRec xs
goCRec xs@(CRec x p) = r x $ stopCRec (p xs)&lt;/p&gt;



&lt;p&gt;&lt;span class=inline-code&gt;stopCRec&lt;/span&gt; is similarly structurally working its way
through the list except that it posesses an induction hypothesis
&lt;span class=inline-code&gt;ih&lt;/span&gt; obtained earlier on by &lt;span class=inline-code&gt;goCRec&lt;/span&gt;. When faced with
a &lt;span class=inline-code&gt;CRec&lt;/span&gt;, we know for sure that we have just followed the
pointer back to where it was declared. As a consequence, we return
the induction hypothesis rather than unfolding the cycle yet
another time.&lt;/p&gt;



&lt;p class=code&gt;stopCRec :: CList a Closed -&gt; forall ph. b ph -&gt; b ph
stopCRec (Cons x xs) ih = c x $ stopCRec xs ih
stopCRec (CRec _ _)  ih = ih&lt;/p&gt;



&lt;p&gt;Now that we have this induction principle, it is really easy to
define a &lt;span class=inline-code&gt;cmap&lt;/span&gt; which outputs a list with a structure
identical to the one we started with.&lt;/p&gt;



&lt;p class=code&gt;cmap :: forall a b. (a -&gt; b) -&gt; List a -&gt; List b
cmap f = cfold (Cons . f) CNil (CRec . f)&lt;/p&gt;



&lt;p&gt;And indeed, &lt;span class=inline-code&gt;cmap (+1) $ CRec 1 (Cons 2)&lt;/span&gt; evaluates down to
&lt;span class=inline-code&gt;CRec 2 (Cons 3)&lt;/span&gt; rather than the detestable
&lt;span class=inline-code&gt;Cons 2 (Cons 3 (Cons 2 (...)))&lt;/span&gt; the naïve solution used to
produce.&lt;/p&gt;



&lt;p&gt;It is also possible to instantiate this very generic scheme down
to ones with simpler types. One such instance is the induction
principle where the return type does not depend on the phantom
type:&lt;/p&gt;



&lt;p class=code&gt;cfoldRec :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt;
            (a -&gt; (b -&gt; b) -&gt; b) -&gt; List a -&gt; b&lt;/p&gt;



&lt;p&gt;An elegant use case of this &lt;span class=inline-code&gt;cfoldRec&lt;/span&gt; is the definition
of the &lt;span class=inline-code&gt;Show&lt;/span&gt; instance for &lt;span class=inline-code&gt;List a&lt;/span&gt; which allows us
to display a finite string representing the cyclic structure in its
entirety. When we encounter the pointer declaration, we output
&quot;rec X. &quot; and keep showing the rest of the list but when the pointer
is used, we simply output &quot;X&quot; and stop.&lt;/p&gt;



&lt;p class=code&gt;instance Show a =&gt; Show (List a) where
  show = cfoldRec (\ x -&gt; (++) (show x ++ &quot; : &quot;)) &quot;[]&quot;
                  (\ x ih -&gt; &quot;rec X. &quot; ++ show x ++ &quot; : &quot; ++ ih &quot;X&quot;)&lt;/p&gt;



&lt;p&gt;And, as we expected, &lt;span class=inline-code&gt;show $ CRec 1 (Cons 2)&lt;/span&gt; now reduces
to the finite string &lt;span class=inline-code&gt;&quot;rec X. 1 : 2 : X&quot;&lt;/span&gt;. It is also possible
to recover a &lt;span class=inline-code&gt;fold&lt;/span&gt;-style function unwinding the cycle by
tying the knot in the third argument: the induction hypothesis
will just be the whole subcomputation itself!&lt;/p&gt;



&lt;p class=code&gt;cfold&#39; :: forall a b. (a -&gt; b -&gt; b) -&gt; b -&gt; List a -&gt; b
cfold&#39; c n = cfoldRec c n r
  where r :: a -&gt; (b -&gt; b) -&gt; b
        &lt;span class=bad&gt;r a ih&lt;/span&gt; = c a (ih $ &lt;span class=bad&gt;r a ih&lt;/span&gt;)&lt;/p&gt;



&lt;p&gt;This is precisely what we want to do when defining the semantics
of these cyclic lists in terms of streams. Hence the really concise
definition:&lt;/p&gt;



&lt;p class=code&gt;toStream :: List a -&gt; [ a ]
toStream = cfold&#39; (:) []&lt;/p&gt;



&lt;p&gt;There are still plenty of functions to implement on this
representation some of which may raise interesting questions:
&lt;span class=inline-code&gt;czip&lt;/span&gt; will surely involve computing a least common
multiple. And it will enable us to define an &lt;i&gt;extensional&lt;/i&gt;
equality on these cyclic structures. Exciting perspectives.&lt;/p&gt;



&lt;a name=&quot;Conclusion&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Conclusion&quot;&gt;#&lt;/a&gt; Conclusion&lt;/h3&gt;



&lt;p&gt;GADTs combined with higher rank polymorphism allowed us to bake
in invariants which were sufficient for us to write more useful
functions than the rather untyped approach led us to believe was
possible. The type of &lt;span class=inline-code&gt;cfold&lt;/span&gt; lets us decide at any time
whether we want to unwind the cycle or not.&lt;/p&gt;



&lt;p&gt;However, this approach is limited to cases in which it only
makes sense to have &lt;i&gt;one&lt;/i&gt; cycle. This is not true anymore
when we consider datastructures which are not linear: a cyclic
tree may have different cycle in different branches, some of
which may be nested. It is then necessary to fall back to a
setup managing syntax with binding.&lt;/p&gt;


&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;We consider here that we only work in the inductive
fragment of the language. It is obviously impossible to enforce in
Haskell.&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/cyclic-list-purely.html</guid><pubDate>Tue, 12 Aug 2014 13:37:00 UTC</pubDate></item><item><title>Non-regular Parameters are OK</title><link>http://gallais.github.io/blog/non-regular-parameters.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Non-regular Parameters are OK&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://www.lix.polytechnique.fr/~barras/habilitation/&quot;&gt;Barras&#39; habil. thesis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;code/NonRegularParameter/NonRegular.agda&quot;&gt;Raw Agda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;code/NonRegularParameter/NonRegular.html&quot;&gt;Colored Agda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;code/NonRegularParameter/NonRegular.v&quot;&gt;Coq equivalent&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;


&lt;p id=chapo&gt;Both Coq and Agda let the user declare datatypes with
non-regular parameters which do vary, are not quite indices and
can be large without bumping the universe level in which the
declaration lives. In his habilitation thesis, Bruno Barras
shows a nice trick explaining why these non-regular parameters
make sense.&lt;/p&gt;




&lt;a name=&quot;QuickDefinition&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#QuickDefinition&quot;&gt;#&lt;/a&gt; Quick definition&lt;/h3&gt;



&lt;p&gt;A non-regular parameter for an inductive type is an (usually large) argument
of the &lt;i&gt;type&lt;/i&gt; constructor which is used uniformly in the return type of its
&lt;i&gt;term&lt;/i&gt; constructors (thus making it parameter-like) but may vary in their
recursive positions (making it index-like).&lt;/p&gt;



&lt;p&gt;First of all, let&#39;s see a couple of use cases for non-regular parameters.

In Ralf Hinze and Ross Paterson&#39;s
&lt;a href=&quot;http://hackage.haskell.org/package/fingertree&quot;&gt;fingertrees&lt;/a&gt;, the
non regular parameter « determines the unusual shape of these trees, which is
the key to their performance »
&lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt;. The non regularity is here used to enforce invariants
in the substructures by tightly controlling which constructors one may use.&lt;/p&gt;



&lt;p class=code&gt;data FingerTree a = Empty
                  | Single a
                  | Deep (Digit a) (FingerTree (Node a)) (Digit a)
&lt;/p&gt;



&lt;p&gt;Using &lt;a href=&quot;?en/main/blog/read/lazy-lambda#section2&quot;&gt;Type-level de Bruijn
indices&lt;/a&gt; in order to bake in a syntax a notion of scope and binding sites
is another use of non regularity. In this case, the invariant we are enforcing
is the fact that one can only talk about variables which are in scope. But it
also formalizes lets us identify clearly the constructors which are binders.&lt;/p&gt;



&lt;p&gt;Now that we have seen that this non-regularity can be useful, we would like
to know whether it is a safe feature. After all, having a system in which
&lt;span class=inline-code&gt;Type : Type&lt;/span&gt; can simplify things quite a lot but it comes at the cost
of being inconsistent...&lt;/p&gt;



&lt;a name=&quot;TheEncoding&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#TheEncoding&quot;&gt;#&lt;/a&gt; The encoding&lt;/h3&gt;



&lt;p&gt;We will not give a generic account of this transformation but explain
it by a simple example. Let&#39;s use the type-level de Bruijn indices case
to demonstrate how one can explain the use of a non-regular parameter in
terms of more basic concepts which are known to be sound. We will work in
Agda but it would be possible to perform the same construction in Coq as
demonstrated by &lt;a href=&quot;code/NonRegularParameter/NonRegularParameter.v&quot;&gt;this
file&lt;/a&gt;.&lt;/p&gt;



&lt;a name=&quot;WhatOneWouldWriteInAgda&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#WhatOneWouldWriteInAgda&quot;&gt;#&lt;/a&gt; What one would write in Agda&lt;/h4&gt;



&lt;p&gt;We start by defining our simple lambda calculus &lt;span class=inline-code&gt;Lam&lt;/span&gt; equipped
with a let binder. The parameter &lt;span class=inline-code&gt;A&lt;/span&gt; represents the variables available
in scope; it needs therefore to be modified every time a binder introduces
fresh ones &lt;a id=&quot;reftop2&quot; href=&quot;#refbot2&quot;&gt;[2]&lt;/a&gt;:&lt;/p&gt;



&lt;p class=code&gt;data Lam (A : Set) : Set where
  `var      : (a : A) → Lam A
  `app      : (t u : Lam A) → Lam A
  `lam      : (t : Lam (1 + A)) → Lam A
  `let_`in_ : {n : ℕ} (t : Vec (Lam A) n) (u : Lam (n + A)) → Lam A
&lt;/p&gt;



&lt;a name=&quot;ANaïveTranslationUsingLargeIndexes&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#ANaïveTranslationUsingLargeIndexes&quot;&gt;#&lt;/a&gt; A naïve translation using large indexes&lt;/h4&gt;



&lt;p&gt;Given that this argument varies in the various recursive positions,
one could consider calling it an index. This is where we run into troubles:
the value &lt;span class=inline-code&gt;A&lt;/span&gt; used to be in context because it was treated like a
parameter; now that we consider it to be an index, every constructor has to
introduce &lt;span class=inline-code&gt;A&lt;/span&gt; to be able to mention it. But &lt;span class=inline-code&gt;A&lt;/span&gt; is large which
forces the datatype declaration to live one level up.&lt;/p&gt;



&lt;p class=code&gt;data Lam : (A : Set) → Set₁ where
  `var      : {A : Set} (a : A) → Lam A
  `app      : {A : Set} (t u : Lam A) → Lam A
  `lam      : {A : Set} (t : Lam (1 + A)) → Lam A
  `let_`in_ : {A : Set} {n : ℕ} (t : Vec (Lam A) n) (u : Lam (n + A)) → Lam A&lt;/p&gt;



&lt;p&gt;This is quite clearly not a satisfactory solution. It is, for instance, now
impossible to define the monadic &lt;span class=inline-code&gt;join&lt;/span&gt; for &lt;span class=inline-code&gt;Lam&lt;/span&gt; because
&lt;span class=inline-code&gt;Lam (Lam A)&lt;/span&gt; is not even a type one can form! If we do need to introduce
an index to track down the modifications made to the non regular parameter then
it&#39;d better be a small one. This is precisely what the encoding does.&lt;/p&gt;



&lt;a name=&quot;Barras&#39;Encoding&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Barras&#39;Encoding&quot;&gt;#&lt;/a&gt; Barras&#39; encoding&lt;/h4&gt;



&lt;p&gt;The important remark behind this encoding is that the shape of
the non-regular parameter at any point in a tree is entirely determined
by the value of the parameter at the root; the path followed from the root
down to this subtree and, potentially, additional information stored in
the nodes encountered along this path. Now, this information has to be small,
otherwise the inductive definition would not fit at its current level. It is
therefore sufficient to store, as a parameter, the value present at the root
and then use a &lt;i&gt;small&lt;/i&gt; index to describe the path followed and the
information accumulated. In the case of our running example, the type of path
is as follows.&lt;/p&gt;



&lt;p class=code&gt;data path : Set where
  `rt : path
  `bd : (n : ℕ) (p : path) → path&lt;/p&gt;



&lt;p&gt;&lt;span class=inline-code&gt;`rt&lt;/span&gt; represents the root of the tree and &lt;span class=inline-code&gt;`bd&lt;/span&gt; (for &quot;binder&quot;)
represents both &lt;span class=inline-code&gt;`lam&lt;/span&gt; and &lt;span class=inline-code&gt;`let_`in_&lt;/span&gt; because we are only
interested in the number of variables introduced by a binding site. We note
that one can blithely forget about the &lt;span class=inline-code&gt;`app&lt;/span&gt; constructors one crossed
because they do not alter the parameter. The &lt;span class=inline-code&gt;decode&lt;/span&gt; function defining
the semantics of these paths is straightforward: the root induces the identity
and a binding site extends the environment with &lt;span class=inline-code&gt;n&lt;/span&gt; new variables.&lt;/p&gt;



&lt;p class=code&gt;decode : (p : path) (A : Set) → Set
decode `rt       A = A
decode (`bd n p) A = n + decode A p&lt;/p&gt;



&lt;p&gt;This allows us to define a datatype in a theory with only parameters and
indices whilst keeping it small. As one would expect, it is possible to prove
that this inductive type is in bijection with the original one. The usual
problem arise with the termination checker when dealing with the nesting
&lt;span class=inline-code&gt;Vec (Lam A) n&lt;/span&gt; but, as usual, inlining &lt;span class=inline-code&gt;Vec.map&lt;/span&gt; is sufficient
to convince Agda that everything is fine.&lt;/p&gt;



&lt;p class=code&gt;data Lam (A : Set) : path → Set where
  `var      : {p : path} (a : decode p A) → Lam A p
  `app      : {p : path} (t u : Lam A p) → Lam A p
  `lam      : {p : path} (t : Lam A (`bd 1 p)) → Lam A p
  `let_`in_ : {p : path} {n : ℕ} (t : Vec (Lam A p) n) (u : Lam A (`bd n p)) →
              Lam A p&lt;/p&gt;



&lt;a name=&quot;Conclusion&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Conclusion&quot;&gt;#&lt;/a&gt; Conclusion&lt;/h3&gt;



&lt;p&gt;Well that was fun! If you want a more general presentation, then have a look
at &lt;a href=&quot;http://www.lix.polytechnique.fr/~barras/habilitation/&quot;&gt;the thesis&lt;/a&gt;
page 138 and following. Beware though: I started reading it because it was
mentioned somewhere that it explained how to make sense, in terms of indexed
families, of mutually defined inductive types leaving at different levels;
and stayed because I kept seeing other interesting topics. It&#39;s a trap.&lt;/p&gt;

&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;Page 4, &lt;a href=&quot;http://www.citeulike.org/user/gallais/article/2399086&quot;&gt;
Finger trees: a simple general-purpose data structure&lt;/a&gt; by Ralf Hinze, Ross
Paterson.&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot2&quot; href=&quot;#reftop2&quot;&gt;[2]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;&lt;span class=inline-code&gt;_+_&lt;/span&gt; of type &lt;span class=inline-code&gt;ℕ → Set → Set&lt;/span&gt; is used here
to mean that a finite number of new bound variable have been introduced by the
binding construct.&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/non-regular-parameters.html</guid><pubDate>Thu, 17 Jul 2014 13:37:00 UTC</pubDate></item><item><title>Lazy Weakening and Equality Test</title><link>http://gallais.github.io/blog/lazy-lambda.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Lazy Weakening and Equality Test&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.fpcomplete.com/user/edwardk/bound&quot;&gt;Intro to bound&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://hackage.haskell.org/package/bound&quot;&gt;bound on Hackage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;code/LazyLambda/LazyLambda.html&quot;&gt;Colored Agda&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;


&lt;p id=chapo&gt;One of the key features of &lt;span class=inline-code&gt;bound&lt;/span&gt; is that it
introduces redundancies in the representation of syntaxes in
order to avoid traversing entire subterms just to apply a
weakening. However, equality testing currently quotients out
these redundancies. In this post, I present a lazy equality
test for the untyped lambda calculus with redundancies which does
not perform any of this extra work.&lt;/p&gt;



&lt;p&gt;This works stems out of a bold statement I made and was called
out on by Thomas Braibant during an emacs-driven seminar given in
front of the smart &lt;a href=&quot;http://gallium.inria.fr/blog/&quot;&gt;gallium&lt;/a&gt;
people. The lazy equality test I claimed could be implemented turned
out to be quite a bit more work than I expected &amp; I was not able to
deliver it when asked to. Better late than never.&lt;/p&gt;



&lt;p&gt;Our running example will be the untyped lambda calculus
with its well-known 3 constructors: &lt;span class=inline-code&gt;var&lt;/span&gt;, &lt;span class=inline-code&gt;lam&lt;/span&gt; and
&lt;span class=inline-code&gt;app&lt;/span&gt;. We will start by motivating the use of the notion
of &lt;span class=inline-code&gt;Scope&lt;/span&gt; when dealing with syntaxes with binding both for
its added safety, genericity and efficiency. We will then move on
to the actual meat of this post: the lazy equality test.&lt;/p&gt;



&lt;a name=&quot;section0&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section0&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;code/LazyLambda/LazyLambda.html#804&quot;&gt;Binding? de Bruijn!&lt;/a&gt;&lt;/h3&gt;



&lt;p&gt;De Bruijn indices are the canonical solution to representing
binding in a language whilst not having to bother with α-conversion.
Here is the inductive definition of the untyped lambda calculus:&lt;/p&gt;



&lt;p class=code&gt;data Lam : Set where
  var : (n : Nat)   → Lam
  app : (t u : Lam) → Lam
  lam : (b : Lam)   → Lam&lt;/p&gt;



&lt;p&gt;Unfortunately this ease of use comes at a price: de Bruijn
indices are an inherently untyped approach to context representation
which means that they don&#39;t push any sanity check into the type
system. Being the silly programmer I am, I always end up writing
nonsensical expressions. The canonical example may very well be the
definition of substitution
&lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt; where one goes under
a binder without even realizing that the former substitution
must be weakened and extended:&lt;/p&gt;



&lt;p class=code&gt;subst : Lam → (Nat → Lam) → Lam
subst (var x)   ρ = ρ x
subst (app t u) ρ = app (subst t ρ) (subst u ρ)
&lt;span class=bad&gt;subst (lam b)   ρ = lam (subst b ρ)&lt;/span&gt; -- this typechecks...
                                    -- ouch!&lt;/p&gt;



&lt;a name=&quot;section1&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section1&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;code/LazyLambda/LazyLambda.html#2195&quot;&gt;Type level de Bruijn indices&lt;/a&gt;&lt;/h3&gt;



&lt;p&gt;Now, de Bruijn indices are a really great idea when it comes
to handling α-equivalence, capture avoidance, looking variables up
in environments, etc. We would like to retain the general idea behind
them whilst being reminded by the typechecker that some magic needs
to happen after a new variable has been bound.&lt;/p&gt;



&lt;p&gt;Typed alternatives to de Bruijn indices do exist; we can e.g.
think of terms well-scoped by constructions using &lt;span class=inline-code&gt;Fin&lt;/span&gt;
or the non-regular datatypes reflecting the indices at the type level
we are going to use:&lt;/p&gt;



&lt;p class=code&gt;data Lam (A : Set) : Set where
  var : (a : A)             → Lam A
  app : (t u : Lam A)       → Lam A
  lam : (b : Lam (Maybe A)) → Lam A&lt;/p&gt;



&lt;p&gt;&lt;span class=inline-code&gt;Lam&lt;/span&gt; quite clearly is a functor hence the existence of
a higher-order function &lt;span class=inline-code&gt;map&lt;/span&gt; which loosely corresponds
to the notion of renaming / weakening &lt;a id=&quot;reftop2&quot; href=&quot;#refbot2&quot;&gt;[2]&lt;/a&gt;.
The &lt;span class=inline-code&gt;var&lt;/span&gt; and &lt;span class=inline-code&gt;app&lt;/span&gt; cases are unchanged but the type
of the lamdba&#39;s body now rejects the erroneous recursive call
described earlier. We are forced to both extend the substitution
with the new bound variable which is unchanged, and weaken the
elements in the rest of the substitution.&lt;/p&gt;



&lt;p class=code&gt;subst : (t : Lam A) (ρ : A → Lam B) → Lam B
subst (var a)   ρ = ρ a
subst (app t u) ρ = app (subst t ρ) (subst u ρ)
subst (lam b)   ρ = lam (subst b ρ&#39;)
  where ρ&#39; none     = var none
        ρ&#39; (some a) = &lt;span class=bad&gt;map some (ρ a)&lt;/span&gt; -- this traverses
                                     -- the whole term&lt;/p&gt;



&lt;p&gt;Unfortunately, this is rather inefficient in that we have to
walk through all the terms in the substitution every time we
pass under a binder.&lt;/p&gt;



&lt;a name=&quot;section2&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section2&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;code/LazyLambda/LazyLambda.html#5159&quot;&gt;Lazy weakenings&lt;/a&gt;&lt;/h3&gt;



&lt;p&gt;In order to avoid traversing the whole term whenever one just
wants to weaken it, it is quite natural to add some redundancies
in the representation. This can be done by letting the variables
in a subterm be either bound by the nearest binder or &lt;i&gt;whole&lt;/i&gt;
subterms living in the non-extended context (aka weakened subterms).
This naturally translates to the following notions of
&lt;span class=inline-code&gt;Scope&lt;/span&gt;:&lt;/p&gt;



&lt;p class=code&gt;Scope : (F : Set → Set) (A : Set) → Set
Scope F A = F (Maybe (F A))&lt;/p&gt;



&lt;p&gt;In this case, the definition is simple enough that Agda has no
problem seeing that the &lt;span class=inline-code&gt;Scope&lt;/span&gt; transformer preserves
positivity and that &lt;span class=inline-code&gt;Lam&lt;/span&gt; is therefore a legal inductive
definition. However in more intricate examples, e.g. when describing
a universe of syntaxes with &lt;span class=inline-code&gt;Scope&lt;/span&gt;s, only a tool like
&lt;a href=&quot;http://www2.tcs.ifi.lmu.de/~abel/miniagda/&quot;&gt;MiniAgda&lt;/a&gt;
which allows for positivity annotations will accept the definition
as valid.&lt;/p&gt;



&lt;p class=code&gt;data Lam (A : Set) : Set where
  var : (a : A)           → Lam A
  app : (t u : Lam A)     → Lam A
  lam : (b : Scope Lam A) → Lam A&lt;/p&gt;



&lt;a name=&quot;section3&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section3&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;code/LazyLambda/LazyLambda.html#7263&quot;&gt;Equality testing&lt;/a&gt;&lt;/h3&gt;



&lt;p&gt;All is well when it comes to substitution but what about
equality testing? We have added redundancies which therefore
need to be quotiented out when comparing two terms. The simplest
way to implement such a comparison function is to define a
function &lt;span class=inline-code&gt;flatten&lt;/span&gt; which will push the weakenings into the
leaves of the terms thus producing terms in &lt;i&gt;de Bruijn normal
form&lt;/i&gt;.&lt;/p&gt;



&lt;p class=code&gt;flatten : (t : Scope Lam A) → Lam (Maybe A)&lt;/p&gt;



&lt;a name=&quot;section4&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section4&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;code/LazyLambda/LazyLambda.html#7932&quot;&gt;Lazy equality testing&lt;/a&gt;&lt;/h3&gt;



&lt;p&gt;Now, we know that we can test terms for equality. But it is not
quite satisfactory yet: we introduced redundancies precisely to avoid
having to perform all of these costly flattenings. But, with a little
bit of work, it is actually possible to perform &lt;i&gt;lazy&lt;/i&gt; equality
testing.&lt;/p&gt;



&lt;a name=&quot;section5&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section5&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;code/LazyLambda/LazyLambda.html#4498&quot;&gt;Context inclusions&lt;/a&gt;&lt;/h4&gt;



&lt;p&gt;One of the tools we are going to need is a way to describe how
different contexts are related. The terms we are going to compare
will both live in a common context but unfolding them may
very-well bring us to widely different places based on the number
of weakenings respectively encountered on the way down to the
current subterms.&lt;/p&gt;



&lt;p&gt;We introduce this notion of inclusion &lt;a id=&quot;reftop3&quot; href=&quot;#refbot3&quot;&gt;[3]&lt;/a&gt;
whose 2nd constructor (&lt;span class=inline-code&gt;↑_&lt;/span&gt;) tags the moment one goes under
a lambda abstraction whilst the 3rd one (&lt;span class=inline-code&gt;◂_&lt;/span&gt;) tags the
moment one encounters a weakening. &lt;/p&gt;



&lt;p class=code&gt;data _⊆_ : (A B : Set) → Set₁ where
  ■  : A ⊆ A
  ↑_ : A ⊆ B → Maybe (Lam A) ⊆ Maybe (Lam B)
  ◂_ : Maybe (Lam A) ⊆ B → A ⊆ B&lt;/p&gt;



&lt;a name=&quot;section6&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section6&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;code/LazyLambda/LazyLambda.html#10054&quot;&gt;Term comparison&lt;/a&gt;&lt;/h4&gt;



&lt;p&gt;Now, we are ready to describe the comparison of two terms living
in their respective local contexts &lt;span class=inline-code&gt;A&lt;/span&gt; and &lt;span class=inline-code&gt;B&lt;/span&gt; both
sharing a common super-context &lt;span class=inline-code&gt;T&lt;/span&gt;.&lt;/p&gt;



&lt;p class=code&gt;data EQ : {T A : Set} (incA : A ⊆ T) (t : Lam A)
          {B : Set}   (incB : B ⊆ T) (u : Lam B)
          → Set₁ where
&lt;/p&gt;


&lt;p&gt;Let&#39;s start off with the easy cases: two applications are equal
whenever their functions (resp. arguments) are equal ; and two
lambda abstractions are equal whenever their bodies are equal in
the extended contexts.&lt;/p&gt;


&lt;p class=code&gt;  EQapp     : EQ incA t₁ incB t₂ →
              EQ incA u₁ incB u₂ →
              EQ incA (app t₁ u₁) incB (app t₂ u₂)

  EQlam     : EQ (↑ incA) b₁ (↑ incB) b₂ →
              EQ incA (lam b₁) incB (lam b₂)&lt;/p&gt;


&lt;p&gt;When two terms claim to be bound variables, we can compare the
context inclusions to check that they refer to the same lambda
binder. We will describe what this check amounts to in the next
section.&lt;/p&gt;


&lt;p class=code&gt;  EQvar     : EQVar incA zero incB zero →
              EQ incA (var none) incB (var none)&lt;/p&gt;


&lt;p&gt;When one of the terms is a weakening of a subterm, we record this
information in the proof of context inclusion and keep on unfolding
further.&lt;/p&gt;


&lt;p class=code&gt;  EQvarFre₁ : EQ (◂ incA) v incB u →
              EQ incA (var (some v)) incB u

  EQvarFre₂ : EQ incA t (◂ incB) v →
              EQ incA t incB (var (some v))
&lt;/p&gt;



&lt;p&gt;The careful reader will have noticed that this description is
mostly syntax-directed except for the two last rules which happen
to commute. Turning this specification into a recursive algorithm
will therefore just be a matter of picking an order in which to
check that either &lt;span class=inline-code&gt;EQvarFre₁&lt;/span&gt; or &lt;span class=inline-code&gt;EQvarFre₂&lt;/span&gt; applies.
Which is good news when you are in the business of actually
deciding equality.&lt;/p&gt;




&lt;a name=&quot;section7&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section7&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;code/LazyLambda/LazyLambda.html#8474&quot;&gt;Variable
comparison&lt;/a&gt;&lt;/h4&gt;



&lt;p&gt;Variable comparison is always done up to weakenings. We count
the numbers of weakenings encountered thus far respectively in
&lt;span class=inline-code&gt;kA&lt;/span&gt; and &lt;span class=inline-code&gt;kB&lt;/span&gt; and manage (in/de)crements based on
the tokens we stumble upon.&lt;/p&gt;



&lt;p class=code&gt;data EQVar : {TA A : Set} (incA : A ⊆ TA) (kA : Nat)
             {TB B : Set} (incB : B ⊆ TB) (kB : Nat)
             → Set₁ where&lt;/p&gt;


&lt;p&gt;When both context inclusions are synchronized on a lambda
binder (tagged by &lt;span class=inline-code&gt;↑_&lt;/span&gt; in the derivations) and no weakening
whatsoever has been applied (both &lt;span class=inline-code&gt;kA&lt;/span&gt; and &lt;span class=inline-code&gt;kB&lt;/span&gt; are
zero) then we can conclude that the variables are indeed equal.&lt;/p&gt;


&lt;p class=code&gt;  EQVarZRO : EQVar (↑ incA) zero (↑ incB) zero
&lt;/p&gt;



&lt;p&gt;When, on the other hand, they both claim to be referring to a
binder which is at least one level up (both &lt;span class=inline-code&gt;kA&lt;/span&gt; and
&lt;span class=inline-code&gt;kB&lt;/span&gt; are non-zero), one can forget about the binder at hand
and go explore the context inclusions upward.&lt;/p&gt;



&lt;p class=code&gt;  EQVarSUC : EQVar incA kA incB kB →
             EQVar (↑ incA) (suc kA) (↑ incB) (suc kB)&lt;/p&gt;


&lt;p&gt;Finally, when we encounter a weakening (marked with a
&lt;span class=inline-code&gt;◂_&lt;/span&gt;), we record its presence by incrementing the appropriate
counter and keep comparing the rest of the inclusion proofs.&lt;/p&gt;



&lt;p class=code&gt;  EQVarWK₁ : EQVar incA (suc kA) incB kB →
             EQVar (◂ incA) kA incB kB

  EQVarWK₂ : EQVar incA kA incB (suc kB) →
             EQVar incA kA (◂ incB) kB&lt;/p&gt;



&lt;a name=&quot;section8&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#section8&quot;&gt;#&lt;/a&gt; &lt;a href=&quot;code/LazyLambda/LazyLambda.html#12026&quot;&gt;Testing equality&lt;/a&gt;&lt;/h4&gt;



&lt;p&gt;As expected, this specification also is mostly syntax-directed
except for commutative steps. It is thus easy to write an algorithm
checking whether such an equality derivation can be built. And it&#39;s
quite a lot simpler to do now that the rules are guiding the
implementation.&lt;/p&gt;

&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;&lt;a href=&quot;http://codereview.stackexchange.com/questions/44470/beta-reducer-in-haskell/44518#44518&quot;&gt;Weakening&lt;/a&gt;
is also a good candidate for this sort of nonsense given that
one easily forgets to protect bound variables and end up treating
them as if they were free.&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot2&quot; href=&quot;#reftop2&quot;&gt;[2]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;It &lt;i&gt;is&lt;/i&gt;
respectively renaming / weakening provided that the function
passed is well-behaved (resp. bijective / injective).&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot3&quot; href=&quot;#reftop3&quot;&gt;[3]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;It makes sense as
a notion of inclusion because a proof that &lt;span class=inline-code&gt;A ⊆ B&lt;/span&gt; gives rise
to a morphism from &lt;span class=inline-code&gt;A&lt;/span&gt; to &lt;span class=inline-code&gt;B&lt;/span&gt;. Cf.
&lt;a href=&quot;code/LazyLambda/LazyLambda.html#4861&quot;&gt;the accompanying Agda doc&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/lazy-lambda.html</guid><pubDate>Mon, 28 Apr 2014 13:37:00 UTC</pubDate></item><item><title>Dimension-Aware Computations</title><link>http://gallais.github.io/blog/dimension-aware-computations.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Dimension-Aware Computations&lt;/h1&gt;&lt;div class=bdocs&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;code/ToyingDimensions/dimensions.html&quot;&gt;Colored Agda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;code/ToyingDimensions/Plot.hs&quot;&gt;Haskell Voodoo&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;



&lt;p id=chapo&gt;Dimensional analysis is quite the tool to track down stupid
mistakes in physics much like a type-checker will detect non-sensical
expressions in your favourite statically-typed programming language.
I have been meaning to toy around with this notion in a dependently-typed
setting for quite a while. Here are a few definitions. As well as an
Agda program that needs to be &lt;i&gt;compiled&lt;/i&gt;.&lt;/p&gt;



&lt;p&gt;On Wednesday, &lt;a href=&quot;http://www.bentnib.org&quot;&gt;Bob&lt;/a&gt; presented at
&lt;a href=&quot;http://homepages.inf.ed.ac.uk/slindley/spls-2013-10/&quot;&gt;SPLS&lt;/a&gt;
a really cool
&lt;a href=&quot;http://bentnib.org/posts/2013-07-17-one-done-two-submitted.html&quot;&gt;
project&lt;/a&gt; he has been working on: a type system which, by parametricity,
derives automagically &lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt; the premises of
&lt;a href=&quot;https://en.wikipedia.org/wiki/Noether&#39;s_theorem&quot;&gt;Noether&#39;s
theorem&lt;/a&gt;. All this talking about physics got me motivated enough to
spend Saturday&#39;s afternoon hacking up a toy example. This is probably not
revolutionary &lt;a id=&quot;reftop2&quot; href=&quot;#refbot2&quot;&gt;[2]&lt;/a&gt; but it was quite
amusing to develop anyway so here it is.&lt;/p&gt;



&lt;a name=&quot;TheDataStructuresInvolved&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#TheDataStructuresInvolved&quot;&gt;#&lt;/a&gt; The data structures involved&lt;/h3&gt;



&lt;p&gt;This whole project is structured as a succession of modules in order to
to have separate name spaces. This way, we can make sure that the different
operations morally implementing the same concepts can have the same name.&lt;/p&gt;



&lt;a name=&quot;Dimensions&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Dimensions&quot;&gt;#&lt;/a&gt; Dimensions&lt;/h4&gt;



&lt;p&gt;We will limit ourselves to 3 types of units of measure here: kilograms,
meters and seconds. The dimension of an object is modelled by a record storing
the exponents assigned to each one of these components.&lt;/p&gt;



&lt;p class=code&gt;record dimension : Set where
  field
    kilogram : ℤ
    meter    : ℤ
    second   : ℤ&lt;/p&gt;



&lt;p&gt;Taking the product of two dimensions amounts to summing the degrees for each
one of the units of measure. Quotienting is, likewise, a pointwise operation on
the two vectors: this time we compute the difference rather than the sum.&lt;/p&gt;



&lt;p class=code&gt;_*_ : (d e : dimension) → dimension
d * e = record { kilogram = kilogram d + kilogram e
               ; meter    = meter d    + meter e
               ; second   = second d   + second e }&lt;/p&gt;



&lt;p&gt;We can now define the basic dimensions: kilograms, meters and seconds by
assigning &lt;span class=inline-code&gt;+ 0&lt;/span&gt; to all the fields except for the one of interest
which is instantiated with &lt;span class=inline-code&gt;+ 1&lt;/span&gt;. As an example, here is the dimension
&lt;span class=inline-code&gt;sec&lt;/span&gt; corresponding to seconds.&lt;/p&gt;



&lt;p class=code&gt;sec = record { kilogram = + 0
             ; meter    = + 0
             ; second   = + 1 }&lt;/p&gt;



&lt;a name=&quot;UnitsOfMeasure&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#UnitsOfMeasure&quot;&gt;#&lt;/a&gt; Units of measure&lt;/h4&gt;



&lt;p&gt;So far, so good. But in real life we quite like to consider other units than
just the basic ones. A &lt;span class=inline-code&gt;unit&lt;/span&gt; of measure is therefore a dimension
together with a non-zero coefficient. The type of &lt;span class=inline-code&gt;hn&lt;/span&gt; has been chosen
so &lt;span class=inline-code&gt;hn&lt;/span&gt; can be inferred by the system in concrete cases (if &lt;span class=inline-code&gt;n&lt;/span&gt;
is non-zero, then &lt;span class=inline-code&gt;hn&lt;/span&gt; is of type &lt;span class=inline-code&gt;⊤&lt;/span&gt; hence equal to &lt;span class=inline-code&gt;tt&lt;/span&gt;)
and to match the requirements imposed by &lt;span class=inline-code&gt;_div_&lt;/span&gt; in the standard
library.&lt;/p&gt;



&lt;p class=code&gt;data unit : Set where
  _,_#_ : (n : ℕ) (hn : False (n ℕ.≟ 0))
          (d : dimension) → unit&lt;/p&gt;



&lt;p&gt;The product of two units is once more a pointwise operations: it is the
combination of the product of their coefficients (which is guaranteed to be
non-zero) and the product of their respective dimensions.&lt;/p&gt;



&lt;p class=code&gt;_*_ : (u v : unit) → unit
(k , hk # d) * (l , hl # e) = k * l , _ # d * e&lt;/p&gt;



&lt;p&gt;It is quite natural to introduce the SI&#39;s prefixes as functions altering a
previously defined unit. In our system, the types of &lt;span class=inline-code&gt;milli&lt;/span&gt;,
&lt;span class=inline-code&gt;centi&lt;/span&gt; and &lt;span class=inline-code&gt;deci&lt;/span&gt; are nastier than the ones presented below
because we are using natural numbers rather than rational ones and division
of a non-zero number by a non-zero number can return zero.&lt;/p&gt;



&lt;p class=code&gt;deca hecto kilo : unit → unit&lt;/p&gt;



&lt;p&gt;A minute is nothing more than 60 seconds. 60 being different from 0 (!), the
proof obligation reduces to the only inhabitant of unit which is inferred by
the system:&lt;/p&gt;



&lt;p class=code&gt;min : unit
min = 60 , _ # sec&lt;/p&gt;



&lt;a name=&quot;Values&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Values&quot;&gt;#&lt;/a&gt; Values&lt;/h4&gt;



&lt;p&gt;Finally, values are just numerical values repackaged together with a unit.
We choose here to have a data constructor forcing the user to explicitly
mention the unit of measure to be attached to the value. It could be avoided
given that &lt;span class=inline-code&gt;d&lt;/span&gt; is a parameter of the data-type but it is quite handy
for documentation purposes and on the fly definition of values.&lt;/p&gt;



&lt;p class=code&gt;data \[_] : (d : unit) → Set where
  ⟨_∶_⟩ : (value : ℕ) (d : unit) → \\[ d ]&lt;/p&gt;



&lt;p&gt;Multiplying to value has to return something of the right dimension but the
scaling factor can be arbitrary (we may multiply &lt;span class=inline-code&gt;kilo&lt;/span&gt; meters by hours
and expect a result in &lt;span class=inline-code&gt;m / s&lt;/span&gt;). Hence the following implementation.
Addition and division behave similarly.&lt;/p&gt;



&lt;p class=code&gt;_*_ : \\[ k , hk #  d ] → \\[ l , hl # e ] →
      \\[ m , hm # d * e ]
_*_ ⟨ vd ∶ ._ ⟩ ⟨ ve ∶ ._ ⟩ =
    ⟨ (k * vd * l * ve) div m ∶ _ ⟩&lt;/p&gt;



&lt;p&gt;Our implementation of value multiplication is so generic in its type that
it does not have the subformula property which will probably be problematic
in large expression where the type of all the subexpressions is not inferrable.
A simple solution is to specialize the return type down to
&lt;span class=inline-code&gt;\\[ 1 , _ # d * e ]&lt;/span&gt; whilst introducing a lifting operation converting
from one type to an other.&lt;/p&gt;



&lt;p class=code&gt;↑ : ∀ {k hk l hl d} → \[ k , hk # d ] → \[ l , hl # d ]
↑ ⟨ v ∶ ._ ⟩ = ⟨ (k * v) div l ∶ _ ⟩&lt;/p&gt;



&lt;a name=&quot;Examples&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Examples&quot;&gt;#&lt;/a&gt; Examples&lt;/h3&gt;



&lt;p&gt;This system tracking dimensions makes sure that we do not make mistakes
when combining different values but it also converts between various units.
For instance, the following expression normalizes to &lt;span class=inline-code&gt;10&lt;/span&gt;.&lt;/p&gt;



&lt;p class=code&gt;60hm/min : \[ deca m / s ]
60hm/min = ⟨ 60 ∶ hecto m ⟩ / ⟨ 1 ∶ min ⟩&lt;/p&gt;



&lt;a name=&quot;Application:SimulatingTheFreeFallOfABall&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Application:SimulatingTheFreeFallOfABall&quot;&gt;#&lt;/a&gt; Application: simulating the free fall of a ball&lt;/h3&gt;



&lt;p&gt;The setting of this simulation is pretty simple: we have a ball
characterized by its position, speed and acceleration in a vertical plan.
The gravitational constant &lt;span class=inline-code&gt;g&lt;/span&gt; corresponding to earth&#39;s attraction
is expressed in &lt;span class=inline-code&gt;m / (s * s)&lt;/span&gt; and equal to &lt;span class=inline-code&gt;10&lt;/span&gt;.

&lt;br /&gt;In order to simulate the free fall of this ball, we are going to apply
Newton&#39;s approximation method: time is discretized and the characterization
of the ball is updated at every single time-step. Here the type system
guarantees that we do not make mistakes.&lt;/p&gt;



&lt;p class=code&gt;newton : ∀ (dt : \[ s ]) (p : point) → point
newton dt p =
  record { accx = accx p
         ; accy = accy p + g
         ; vx   = vx p   + (accx p :* dt)
         ; vy   = vy p   + (accy p :* dt)
         ; x    = x p    + (vx p   :* dt)
         ; y    = y p    + (vy p   :* dt) }&lt;/p&gt;



&lt;p&gt;A simulation consists in applying repeatedly this newton transformation
to an initial point. We define the &lt;span class=inline-code&gt;throw&lt;/span&gt; function doing exactly
this and generating a trace of all the successive positions.&lt;/p&gt;



&lt;p class=code&gt;throw : (n : ℕ) (dt : \[ s ]) → point → Vec point (ℕ.suc n)
throw zero    dt p = p ∷ \[]
throw (suc n) dt p = p ∷ throw n dt (newton dt p)&lt;/p&gt;



&lt;p&gt;After a little bit of magic, we are able to call a tracing function from
Haskell&#39;s &lt;a href=&quot;http://hackage.haskell.org/package/gnuplot-0.5.1&quot;&gt;Gnuplot&lt;/a&gt;
wrapper and generate the following graph showing the (upside-down) ball&#39;s
trajectory in the vertical plan.&lt;/p&gt;


&lt;center&gt;&lt;img src=&quot;/img/freefall.png&quot; /&gt;&lt;/center&gt;


&lt;a name=&quot;Conclusions&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Conclusions&quot;&gt;#&lt;/a&gt; Conclusions&lt;/h3&gt;



&lt;p&gt;First of all, it works quite well for a first experiment! In a serious
implementation though, one should really use, at the very least, rational
numbers to represent the coefficients. This would ensure that conversion
ratios can be properly computed and make the work a lot more useful.
It is no coincidence that my example involving a speed expressed in
&lt;i&gt;distance per minutes&lt;/i&gt; precisely picks a distance which is a multiple of
&lt;span class=inline-code&gt;60&lt;/span&gt;... I haven&#39;t had the internet connection, the time nor the
desire to see whether appropriate libraries already exist for Agda or to
write my own ones.
&lt;br /&gt;Similarly, the fact that the free fall is represented upside-down is a
direct consequence of the values not being integers but rather natural
numbers (once more due to a lack of libraries in Agda: &lt;span class=inline-code&gt;div&lt;/span&gt; and
&lt;span class=inline-code&gt;mod&lt;/span&gt; are only available for ℕ in the standard library).&lt;/p&gt;



&lt;p&gt;And Agda&#39;s automatic case-splitting, support for Unicode, definition of
functions &lt;i&gt;via&lt;/i&gt; equations, my (ridiculously small but good enough)
understanding of how to import Haskell function as postulates, etc. kept me
away from Coq (at least for the experimentation phase).&lt;/p&gt;

&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;A good start to learn about the free lunch
provided by parametricity is obviously Phil Wadler&#39;s &lt;i&gt;Theorems for Free!&lt;/i&gt;
(&lt;a href=&quot;http://www.citeulike.org/user/gallais/article/1848264&quot;&gt;citeulike&lt;/a&gt;).
&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot2&quot; href=&quot;#reftop2&quot;&gt;[2]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;Andrew Kennedy&#39;s paper &lt;i&gt;Types for
Units-of-Measure: Theory and Practice&lt;/i&gt; mentions that abusing C++ or
Haskell&#39;s type systems makes it possible to « achieve it, but at some cost
in usability ». Arguably, a real dependently-typed language is more suited
for computing at the type level in this fashion.&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/dimension-aware-computations.html</guid><pubDate>Sat,  2 Nov 2013 13:37:00 UTC</pubDate></item><item><title>Glueing terms to models</title><link>http://gallais.github.io/blog/glueing-terms-models.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;Glueing terms to models&lt;/h1&gt;&lt;div class=bdocs&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://patch-tag.com/r/gallais/agda/snapshot/current/content/raw/src/nbe/gluedmodel.agda&quot;&gt;Raw Agda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;/code/GlueingModel/gluedmodel.html&quot;&gt;Colored Agda&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;


&lt;p id=chapo&gt;Today I want to talk about something I came up with when
working on questions connected to the material presented in our
&lt;a href=&quot;/pdf/icfp13.pdf&quot;&gt;ICFP submission&lt;/a&gt; but we did not get the
opportunity to discuss in the paper. The claim is that glueing
terms to the structure of a model allows the reader to get a good
intuition of the way the calculus works by making explicit what used
to be hidden &lt;i&gt;under the hood&lt;/i&gt;.&lt;/p&gt;



&lt;p&gt;I learned about the glueing technique whilst reading about
models of the simply-typed SK combinatorial calculus
&lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt;. Glueing is described as a tool to
circumvent the mismatch between the really restrictive structure of
SK terms and the rather liberal (naïve) model: if one is able to
evaluate SK terms in the model, it is however impossible to extract
normal forms from the semantical objects without applying some kind of lambda to SK encoding procedure! Glueing syntactical terms
to their semantical counterparts is precisely what is required by
the procedure to be able to reify partial applications of S and K.&lt;/p&gt;



&lt;p&gt;Glueing resurfaced later on in my own experimentations when
defining a model for a weak-head normalization by evaluation
&lt;a id=&quot;reftop2&quot; href=&quot;#refbot2&quot;&gt;[2]&lt;/a&gt;.
Indeed, the need to be able to throw away unnecessary computations
(e.g. the argument part of a stuck application should not be
reduced) is easily met by enriching the model with syntactical
artefacts corresponding to &lt;i&gt;source terms&lt;/i&gt; for the semantical
objects. A pleasant side-effet of the added structure is the
simplification of the formulation and proofs of correctness
properties in Type Theory.&lt;/p&gt;



&lt;a name=&quot;TheSetting&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#TheSetting&quot;&gt;#&lt;/a&gt; The setting&lt;/h3&gt;



&lt;p&gt;But in this blog post I would like to argue that there is more
to it than merely solving these kind of problems: glueing can be
used to obtain a well-structured model highlighting some nice
properties of the calculus. The setting for this example is the
definition of a normalization function for the simply-typed lambda
calculus which does not require a glueing to be defined. Types are
either the base, uninterpreted, type or arrow types:&lt;/p&gt;



&lt;p class=code&gt;σ, τ : ty ∷= ♭ | σ `→ τ&lt;/p&gt;



&lt;p&gt;Our well-typed terms using de Bruijn indices are boring so we
will have a look at the definition of normal forms instead. By
definition, only stuck expressions (a variable followed by a spine
of arguments in normal form) of the base type can be regarded as
normal forms. The equational theory will accordingly include eta
rules.&lt;/p&gt;



&lt;p class=code&gt;  data _⊢ne_ (Γ : Con ty) : ty → Set where
    `v   : (pr : σ ∈ Γ)                     → Γ ⊢ne σ
    _`$_ : (f : Γ ⊢ne σ `→ τ) (x : Γ ⊢nf σ) → Γ ⊢ne τ

  data _⊢nf_ (Γ : Con ty) : ty → Set where
    `↑_ : (t : Γ ⊢ne ♭)     → Γ ⊢nf ♭
    `λ_ : (b : Γ ∙ σ ⊢nf τ) → Γ ⊢nf σ `→ τ&lt;/p&gt;



&lt;p&gt;All these notions obviously come with the expected weakening
operations.&lt;/p&gt;



&lt;a name=&quot;ModelDefinition-WhereTheGlueingHappens&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#ModelDefinition-WhereTheGlueingHappens&quot;&gt;#&lt;/a&gt; Model definition - where the glueing happens&lt;/h3&gt;



&lt;p&gt;The model is defined in terms of reduction-free elements: the
interpretation of a term is either a neutral form which will just
grow when being eliminated or it is a normal form together with
an element of the &lt;i&gt;acting&lt;/i&gt; model explaining what its behaviour
is.&lt;/p&gt;



&lt;p class=code&gt;  _⊩_ : ∀ (Γ : Con ty) (σ : ty) → Set
  Γ ⊩ σ =   Γ ⊢ne σ
          ⊎ Γ ⊢nf σ × Γ ⊩⋆ σ&lt;/p&gt;



&lt;p&gt;The acting model is the part of the model doing all the heavy
lifting when &lt;i&gt;computational&lt;/i&gt; reductions are required. It has
a Kripke flavour in the sense that it refers to the full model in
any possible future context extension. Quite unsurprisingly, a
term of base type has no computational content (it can only be
a neutral) and elements of function type are interpreted as
functions on semantical objects.&lt;/p&gt;



&lt;p class=code&gt;  _⊩⋆_ : ∀ (Γ : Con ty) (σ : ty) → Set
  Γ ⊩⋆ ♭      = ⊤
  Γ ⊩⋆ σ `→ τ = ∀ {Δ} (inc : Γ ⊆ Δ) → Δ ⊩ σ → Δ ⊩ τ&lt;/p&gt;



&lt;p&gt;These definitions are easily extended to contexts by recursion
and give rise to semantical environments &lt;span class=inline-code&gt;Δ ⊩ε Γ&lt;/span&gt;. A natural
notion of weakening can be made formal.&lt;/p&gt;



&lt;a name=&quot;The(notSo)TrivialQuotingFunction&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#The(notSo)TrivialQuotingFunction&quot;&gt;#&lt;/a&gt; The (not so) trivial quoting function&lt;/h3&gt;



&lt;p&gt;Because of the way the model is defined, there is little to no
mystery that proving that each element has an image in the model
amounts to proving the existence of a procedure turning terms into
their cut-free equivalents.&lt;/p&gt;



&lt;p&gt;Even if the definitions of quote and unquote are straightforward,
they are rather unusual: unlike their more traditional analogues, they
confine the uses of eta-expansion at reification time. This has to be
compared to the motto &lt;i&gt;eta-expansion both at the syntactical and
semantical level&lt;/i&gt; usually associated with the (un)quote functions.
Additionally, this syntactic work is performed in a standalone
function &lt;span class=inline-code&gt;eta[_]_&lt;/span&gt;
&lt;a id=&quot;reftop3&quot; href=&quot;#refbot3&quot;&gt;[3]&lt;/a&gt; which
is model agnostic.&lt;/p&gt;



&lt;p class=code&gt;eta[_]_ : ∀ {Γ} σ (T : Γ ⊢ne σ) → Γ ⊢nf σ
eta[ ♭      ] t = `↑ t
eta[ σ `→ τ ] t = `λ eta[ τ ] (wk-ne inc t `$ var)
  where inc = step (same _)
        var = eta[ σ ] `v here!&lt;/p&gt;



&lt;p&gt;This way of organizing extraction of normal forms from the model
brings us closer to a staged reduction process which deals
with computations (beta, delta, iota) first and then reorganizes
the cut-free forms using extra rules (eta, nu &lt;a id=&quot;reftop4&quot; href=&quot;#refbot4&quot;&gt;[4]&lt;/a&gt;) than your
average normalization by evaluation formalization.&lt;/p&gt;



&lt;a name=&quot;EvaluationFunction&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#EvaluationFunction&quot;&gt;#&lt;/a&gt; Evaluation function&lt;/h3&gt;



&lt;p&gt;By combining weakening for semantical environments and unquote,
we can define a diagonal environment &lt;span class=inline-code&gt;Γ ⊩ε Γ&lt;/span&gt; for every
&lt;span class=inline-code&gt;Γ&lt;/span&gt;. In order to be able to extract normal forms from
simple terms, it is thus enough to define an evaluation function.&lt;/p&gt;



&lt;p class=code&gt;eval : (t : Γ ⊢ σ) (ρ : Δ ⊩ε Γ) → Δ ⊩ σ&lt;/p&gt;



&lt;p&gt;&lt;span class=inline-code&gt;eval&lt;/span&gt; is defined by induction on the structure of the term
&lt;span class=inline-code&gt;t&lt;/span&gt;. In the variable case, a simple lookup in the semantical
environment produces the well-typed value needed. The application
case combines the induction hypotheses using &lt;span class=inline-code&gt;_$$_&lt;/span&gt;, a
function defined by case analysis on the function: if the function
is stuck, the application also is whereas if it is live, the action
model will compute further using the argument.&lt;/p&gt;



&lt;p class=code&gt;_$$_ : (F : Γ ⊩ σ `→ τ) (X : Γ ⊩ σ) → Γ ⊩ τ
inj₁ f       $$ X = inj₁ (f `$ ↑[ _ ] X)
inj₂ (f , F) $$ X = F (⊆-refl _) X&lt;/p&gt;



&lt;p&gt;The lambda abstraction case is defined in two steps: first the
object &lt;span class=inline-code&gt;B&lt;/span&gt; in the acting model can be generated by applying
the induction hypothesis for the body of the lambda in an extended
(and weakened) environment. And then the normal form is generated
by quoting the object obtained when applying &lt;span class=inline-code&gt;B&lt;/span&gt; to the
variable bound by the head lambda.&lt;/p&gt;


&lt;p class=code&gt;eval (`λ t) ρ = inj₂ (`λ ↑B , B)
  where B  : _ ⊩⋆ _ `→ _
        B  = λ inc X → eval t (wk-⊩ε _ inc ρ , X)
        ↑B = ↑[ _ ] B (step (⊆-refl _)) (↓[ _ ] `v here!)&lt;/p&gt;



&lt;p&gt;Now we can just tie the knot and combine the diagonal environment
with the evaluation function and quote in order to obtain a
normalization procedure.&lt;/p&gt;



&lt;p class=code&gt;norm[_]_ : ∀ {Γ} σ (t : Γ ⊢ σ) → Γ ⊢nf σ
norm[ σ ] t = ↑[ σ ] eval t (⊩ε-refl _)&lt;/p&gt;



&lt;a name=&quot;Conclusions&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Conclusions&quot;&gt;#&lt;/a&gt; Conclusions&lt;/h3&gt;



&lt;p&gt;We recalled that glueing can help us give more structure to our
models thus circumventing limitations of the naïve ones. But, more
importantly, we have also shown that this technique can produce new
insights on already well understood constructions by e.g. making it
possible to isolate different stages of the normalization process:
computation and standardization in our case.&lt;/p&gt;

&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;Intuitionistic model constructions and normalization
proofs by Thierry Coquand and Peter Dybjer
(&lt;a href=&quot;http://www.citeulike.org/user/gallais/article/8927583&quot;&gt;citeulike&lt;/a&gt;)&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot2&quot; href=&quot;#reftop2&quot;&gt;[2]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;&lt;a href=&quot;http://patch-tag.com/r/gallais/agda/snapshot/current/content/raw/src/nbe/stlc/whnf/model.agda&quot;&gt;Raw Agda&lt;/a&gt; development on patch-tag.&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot3&quot; href=&quot;#reftop3&quot;&gt;[3]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;It should be noted that the traditional eta-expansion trick
(&lt;span class=inline-code&gt;↑[ σ ] ↓[ σ ] t&lt;/span&gt;) consisting of drowning the neutral term
in the model and refying it back immediately after is precisely
equal to applying &lt;span class=inline-code&gt;eta[ σ ]&lt;/span&gt; to &lt;span class=inline-code&gt;t&lt;/span&gt;.&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot4&quot; href=&quot;#reftop4&quot;&gt;[4]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;A set of
rules reorganizing stuck recursive functions we introduce in our
&lt;a href=&quot;/pdf/icfp13.pdf&quot;&gt;ICFP submission&lt;/a&gt; (This is starting to
sound like an advertisement campaign... ¬_¬).&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/glueing-terms-models.html</guid><pubDate>Tue, 30 Apr 2013 13:37:00 UTC</pubDate></item><item><title>A universe for syntax with binding</title><link>http://gallais.github.io/blog/syntax-binding-run-omega.html</link><description>&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://gallais.github.io/css/main.css&quot; /&gt;&lt;/head&gt;&lt;span style=&quot;float:right&quot;&gt;&lt;a href=&quot;/rss.xml&quot;&gt;&lt;img src=&quot;/img/rss.png&quot; /&gt;&lt;/a&gt;&lt;/span&gt;&lt;h1&gt;A universe for syntax with binding&lt;/h1&gt;&lt;div class=bdocs&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;http://patch-tag.com/r/gallais/agda/snapshot/current/content/raw/src/generic/unindexed.agda&quot;&gt;Raw Agda&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;code/SyntaxWithBinding/unindexed.html&quot;&gt;Colored Agda&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;



&lt;p id=chapo&gt;Generic programming has proven useful to define automatically operations
acting on datatypes &lt;i&gt;à la&lt;/i&gt; deriving in Haskell. However usual presentations
do not allow the user to highlight some constructors as binding variables in the
context. For every language with binders defined in such a universe, it is therefore
necessary to define manually substitution and to prove its properties.

&lt;br /&gt;In this blog post, we strive to define a universe for syntaxes with binding
for which substitution can be defined generically.&lt;/p&gt;



&lt;p&gt;Operations such as maps, induction principles, equality tests, etc. acting on
inductive datatypes can be defined generically over datatypes inhabiting a universe.
Altenkirch and McBride &lt;a id=&quot;reftop1&quot; href=&quot;#refbot1&quot;&gt;[1]&lt;/a&gt; have shown how
dependently-typed systems can accomodate these mechanisms as a set of libraries
rather than e.g. a pre-processor.&lt;/p&gt;



&lt;a name=&quot;TheUniverse&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#TheUniverse&quot;&gt;#&lt;/a&gt; The universe&lt;/h3&gt;



&lt;p&gt;Our set of description constructors is basically identical to the one of McBride
in his paper on ornaments &lt;a id=&quot;reftop2&quot; href=&quot;#refbot2&quot;&gt;[2]&lt;/a&gt;
except for an extra constructor which allows us to introduce a new variable. It
comes with a decoding function which, for this is the non dependent case, can be
defined separately. We will however present each constructor together with its
semantics given by the decoding function &lt;span class=inline-code&gt;⟦_⟧&lt;/span&gt; in the pure tradition of
Induction-Recursion &lt;a id=&quot;reftop3&quot; href=&quot;#refbot3&quot;&gt;[3]&lt;/a&gt;. This decoding function defines an endofunctor on &lt;span class=inline-code&gt;List V → Set&lt;/span&gt;.&lt;/p&gt;



&lt;p class=code&gt;data Desc : Set₁ where
⟦_⟧ : ∀ {V} → Desc → (R : List V → Set) → List V → Set&lt;/p&gt;



&lt;p&gt;Sigma types can either be used in a non-dependent fashion in order to store
elements of a set inside the structure of the datatype e.g. when defining lists;
or to give the user a set (indexed by &lt;span class=inline-code&gt;A&lt;/span&gt; of different constructors she may
use.&lt;/p&gt;



&lt;p class=code&gt;`σ[_]_ : (A : Set) → (da : (a : A) → Desc) → Desc
⟦ `σ[ A ] d ⟧ R Γ = Σ A (λ a → ⟦ d a ⟧ R Γ)&lt;/p&gt;



&lt;p&gt;Recursive positions are the variable positions in the functor and are therefore
interpreted by &lt;span class=inline-code&gt;R&lt;/span&gt; which will be the fixpoint itself when tying the knot.
They correspond to e.g. the tail of the list in the description of the &lt;span class=inline-code&gt;_∷_&lt;/span&gt;
constructor.&lt;/p&gt;



&lt;p class=code&gt;`r_ : (d : Desc) → Desc
⟦ `r d ⟧ R Γ = R Γ × ⟦ d ⟧ R Γ&lt;/p&gt;



&lt;p&gt;Units are used to state that a description is finished. In the indexed case,
they will be tagged with an index restricting the type of the branch they belong
to.&lt;/p&gt;



&lt;p class=code&gt;`1 : Desc
⟦ `1 ⟧ R Γ = ⊤&lt;/p&gt;



&lt;p&gt;Binders expect the user to provide an identifier for the bound variable and
then keep going through the reste of the definition with an extended context.
In this post, we never use informative identifiers but we can easily imagine
taking advantage of a set with decidable equality to alleviate the burden of
calling a variable by providing a proof that it belongs to an environment.&lt;/p&gt;



&lt;p class=code&gt;`λ_ : (d : Desc) → Desc
⟦ `λ d ⟧ R Γ = Σ _ (λ v → ⟦ d ⟧ R (v ∷ Γ))&lt;/p&gt;



&lt;p&gt;So far so good but... we have no way to actually use a variable! Sure, we can
declare as many new ones as we fancy and have the joy of seeing them floating
around in the context, but we might want to actually do something with them at
some point.&lt;/p&gt;



&lt;a name=&quot;WhatIsAVariable?&quot; /&gt;
&lt;h4&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#WhatIsAVariable?&quot;&gt;#&lt;/a&gt; What is a variable?&lt;/h4&gt;



&lt;p&gt;In our universe with binders, we want to have a substitution operation
generically defined on all the datatypes using binding. In other words, a
variable&#39;s only purpose is to be substituted by a &quot;proper&quot; term. In a sense,
a variable is just a placeholder for a &quot;real&quot; term, an excuse for an inhabitant
which has not been crafted yet.
&lt;br /&gt;This is the reason why variables are treated separately: a whole subterm and
a variable should be on an equal footing. This ascertainment induces us to enrich
the meaning endofunctor with a position for variables right before building its
fixpoint.&lt;/p&gt;



&lt;p class=code&gt;L⟦_⟧ : ∀ {V} → Desc → (R : List V → Set) → List V → Set
L⟦ d ⟧ R Γ = Σ _ (λ v → v ∈ Γ) ⊎ ⟦ d ⟧ R Γ

data `μ {V} (d : Desc) (Γ : List V) : Set where
  `⟨_⟩ : (t : L⟦ d ⟧ (`μ d) Γ) → `μ d Γ&lt;/p&gt;



&lt;p&gt;Obviously Agda does not complain about our definition: the described functors
are strictly positive by construction and accordingly have a fixpoint.&lt;/p&gt;



&lt;a name=&quot;DefiningSubstitution&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#DefiningSubstitution&quot;&gt;#&lt;/a&gt; Defining substitution&lt;/h3&gt;



&lt;p&gt;We call substitution for &lt;span class=inline-code&gt;d&lt;/span&gt; from &lt;span class=inline-code&gt;Γ&lt;/span&gt; to &lt;span class=inline-code&gt;Δ&lt;/span&gt;, a function
which provides for each variable in &lt;span class=inline-code&gt;Γ&lt;/span&gt; a term of type &lt;span class=inline-code&gt;`μ d&lt;/span&gt;
using variables taken in &lt;span class=inline-code&gt;Δ&lt;/span&gt;.&lt;/p&gt;



&lt;p class=code&gt;subst[_] : ∀ {V} → Desc → List V → List V → Set
subst[ d ] Γ Δ = ∀ v → v ∈ Γ → `μ d Δ&lt;/p&gt;



&lt;p&gt;As one would expect from the name of this function, given a substitution for
&lt;span class=inline-code&gt;d&lt;/span&gt; from &lt;span class=inline-code&gt;Γ&lt;/span&gt; to &lt;span class=inline-code&gt;Δ&lt;/span&gt; and a term in &lt;span class=inline-code&gt;`μ d&lt;/span&gt; with free
variables ranging in &lt;span class=inline-code&gt;Γ&lt;/span&gt;, one can build a term in &lt;span class=inline-code&gt;`μ d&lt;/span&gt; only using
variables in &lt;span class=inline-code&gt;Δ&lt;/span&gt;. The whole process corresponds to applying this substitution
and is defined by two mutually defined functions.
&lt;br /&gt;A term is either a variable, in which case we can just apply the substitution,
or it is an inhabitant of the functor applied to the fixpoint and we rely on the
helper function to propagate calls to the substitution on recursive positions.&lt;/p&gt;



&lt;p class=code&gt;mutual
  _∶_⇇_ : ∀ {V} {Γ Δ : List V} d (t : `μ d Γ)
    (ρ : subst[ d ] Γ Δ) → `μ d Δ
  d ∶ `⟨ inj₁ (v , pr) ⟩ ⇇ ρ = ρ v pr
  d ∶ `⟨ inj₂ t        ⟩ ⇇ ρ = `⟨ inj₂ (map⟦ d ⟧ t ρ) ⟩&lt;/p&gt;



&lt;p&gt;The helper function is quite straightforward to define except for the case
where we go under a binder. In this case, we extend the substitution with the
identity on the first variable and weaken the terms corresponding to the other
ones. The careful reader will notice the generalization applied to the type of
the recursive positions to ensure that the definition goes through. In practice,
all direct calls to &lt;span class=inline-code&gt;map⟦_⟧&lt;/span&gt; will be such that &lt;span class=inline-code&gt;d = e&lt;/span&gt;.&lt;/p&gt;



&lt;p class=code&gt;  map⟦_⟧ : ∀ {V} d {e} {Γ Δ : List V} (t : ⟦ d ⟧ (`μ e) Γ)
    (ρ : subst[ e ] Γ Δ) → ⟦ d ⟧ (`μ e) Δ
  map⟦ `σ[ A ] d ⟧ (a , t) ρ = a         , map⟦ d a ⟧ t ρ
  map⟦ `r d      ⟧ (r , t) ρ = _ ∶ r ⇇ ρ , map⟦ d ⟧ t ρ
  map⟦ `1        ⟧ t       ρ = t
  map⟦ `λ d      ⟧ (v , t) ρ = v , map⟦ d ⟧ t ρ&#39;
    where ρ&#39; = λ { .v z      → `⟨ inj₁ (v , z) ⟩ ;
                    w (s pr) → weaken _ _ (ρ w pr) }&lt;/p&gt;



&lt;p&gt;Given an easy proof relying on weakening that the identity substitution exists,
it is rather easy to define what&#39;s named β reduction in the lambda calculus.&lt;/p&gt;



&lt;p class=code&gt;βred : ∀ {V} d {Γ v} → `μ d (v ∷ Γ) → `μ d Γ → `μ d Γ
βred d {Γ} {v} t u = d ∶ t ⇇ ρ
  where ρ = λ { .v z      → u ;
                 w (s pr) → subst-id d Γ w pr }&lt;/p&gt;



&lt;a name=&quot;Examples&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Examples&quot;&gt;#&lt;/a&gt; Examples&lt;/h3&gt;



&lt;p&gt;When building examples, we introduce enumerations of labels corresponding to
the different constructors of the language. We hope the definitions of the various
&lt;span class=inline-code&gt;Desc&lt;/span&gt; functors to be easier to understand this way.
&lt;br /&gt;Let&#39;s start with a very simple language: the untyped lambda calculus. Its
grammar has two components: one can introduce a lambda abstraction (label
&lt;span class=inline-code&gt;lam&lt;/span&gt;) which binds a variable and contains a subterm (a recursive position
&lt;span class=inline-code&gt;`r&lt;/span&gt;) or an applications (label &lt;span class=inline-code&gt;app&lt;/span&gt;) which contains two subterms.
The set of lambda terms with variables in &lt;span class=inline-code&gt;Γ&lt;/span&gt; is then given by &lt;span class=inline-code&gt;`μ&lt;/span&gt;.
The set of closed terms is therefore &lt;span class=inline-code&gt;lc []&lt;/span&gt;&lt;/p&gt;



&lt;p class=code&gt;lc-grammar : Desc
lc-grammar =
  `σ[ lc-labl ] λ { lam → `λ `r `1 ;
                    app → `r `r `1 }

lc : ∀ (Γ : List ⊤) → Set
lc Γ = `μ lc-grammar Γ&lt;/p&gt;



&lt;p&gt;Using Andjelkovic and Gundry&#39;s pattern synonyms &lt;a id=&quot;reftop4&quot; href=&quot;#refbot4&quot;&gt;[4]&lt;/a&gt;, we can recover a nice syntax closer to the one we are
used to. Our lambdas, variables and applications will desugar to the somewhat
horrendous codes describing elements of the fixpoint of &lt;span class=inline-code&gt;lc-grammar&lt;/span&gt;.
We can, for instance, define the well-known looping function &lt;span class=inline-code&gt;:Ω&lt;/span&gt;.&lt;/p&gt;



&lt;p class=code&gt;:δ :Ω : lc []
:δ = :λ :v z :$ :v z
:Ω = :δ :$ :δ&lt;/p&gt;



&lt;p&gt;We can now define a function &lt;span class=inline-code&gt;fire : lc [] → Maybe (lc [])&lt;/span&gt; which explores
a (closed) term looking for a redex and returns either nothing if the term is in
weak-head normal form or just the term after having fired the first redex encountered.
Iterating &lt;span class=inline-code&gt;fire&lt;/span&gt; on a term gives rise to an &lt;span class=inline-code&gt;execute&lt;/span&gt; function
which produces a &lt;span class=inline-code&gt;CoList&lt;/span&gt; of successive reducts.&lt;/p&gt;



&lt;p&gt;As one would expect, running &lt;span class=inline-code&gt;:Ω&lt;/span&gt; yields an infinitely long &lt;span class=inline-code&gt;CoList&lt;/span&gt;
of &lt;span class=inline-code&gt;:Ω&lt;/span&gt;s.&lt;/p&gt;



&lt;p class=code&gt;lemma : execute :Ω ≣ repeat :Ω
lemma = ∷ ♯ lemma&lt;/p&gt;



&lt;a name=&quot;What&#39;sNext?&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#What&#39;sNext?&quot;&gt;#&lt;/a&gt; What&#39;s next?&lt;/h3&gt;



&lt;p&gt;I cooked up the &lt;a href=&quot;http://patch-tag.com/r/gallais/agda/snapshot/current/content/raw/src/generic/indexed.agda&quot;&gt;indexed version&lt;/a&gt;
with which it is possible to get sexy well-typed terms for the simply-typed lambda
calculus such as &lt;span class=inline-code&gt;`K&lt;/span&gt;. But that is another story.&lt;/p&gt;



&lt;p class=code&gt;`K : ∀ {Γ σ τ} → Γ ⊢ σ `→ τ `→ σ
`K = :λ :λ :v (s z)&lt;/p&gt;

&lt;a name=&quot;Footnotes&quot; /&gt;
&lt;h3&gt;&lt;a class=&quot;sectionref&quot; href=&quot;#Footnotes&quot;&gt;#&lt;/a&gt; Footnotes&lt;/h3&gt;&lt;div class=&quot;footnotes&quot;&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot1&quot; href=&quot;#reftop1&quot;&gt;[1]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;&lt;a href=&quot;http://www.citeulike.org/user/gallais/article/6926730&quot;&gt;
Generic Programming within Dependently Typed Programming&lt;/a&gt;&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot2&quot; href=&quot;#reftop2&quot;&gt;[2]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;Ornamental algebras, algebraic ornaments
(&lt;a href=&quot;https://personal.cis.strath.ac.uk/conor.mcbride/pub/OAAO/Ornament.pdf&quot;&gt;pdf&lt;/a&gt;)&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot3&quot; href=&quot;#reftop3&quot;&gt;[3]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;Cf. e.g. Peter Dybjer&#39;s &lt;a href=&quot;http://www.cse.chalmers.se/~peterd/papers/inductive.html&quot;&gt;
work&lt;/a&gt;.&lt;/div&gt;&lt;/p&gt;&lt;p class=&quot;footnote&quot;&gt;&lt;div class=&quot;footnote-number&quot;&gt;&lt;a id=&quot;refbot4&quot; href=&quot;#reftop4&quot;&gt;[4]&lt;/a&gt;&lt;/div&gt;&lt;div class=&quot;footnote-body&quot;&gt;
&lt;a href=&quot;http://code.google.com/p/agda/issues/detail?id=495&quot;&gt;Feature request&lt;/a&gt;
on agda&#39;s bug tracker.&lt;/div&gt;&lt;/p&gt;&lt;/div&gt;</description><guid isPermaLink="true">http://gallais.github.io/blog/syntax-binding-run-omega.html</guid><pubDate>Thu, 11 Apr 2013 13:37:00 UTC</pubDate></item></channel></rss>