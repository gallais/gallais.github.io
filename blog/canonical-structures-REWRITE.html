<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Canonical Structures in Agda using REWRITE</title>
    <link rel="stylesheet" type="text/css" href="../css/main.css" />
    <link rel="alternate" type="application/rss+xml" href="../rss.xml" title="blog">
  </head>
  <body>
    <div id="header">
      <div class="flat_list">
      <ul>
        <li><a href="../index.html">home</a></li>
        <li>||</li>
        <li><a href="../publis.html">publications</a></li>
        <li>||</li>
        <li><a href="../teaching.html">teaching</a></li>
        <li>||</li>
        <li><a href="../thesis.html">thesis</a></li>
        <li>||</li>
        <li><a href="../blog/index.html">blog</a></li>
        <li>||</li>
        <li><a href="../contact.html">contact</a></li>
      </ul>
      </div>
    </div>
    <div id="container">

      <div class="bdocs"><ul><li><a href="https://github.com/agda/agda/blob/0716021c904186ca806a34fe110ae0fca4a3dd70/src/full/Agda/TypeChecking/Rewriting.hs#L5L42">REWRITE's documentation</a></li>
<li><a href="https://gist.github.com/gallais/438793c5ed7988826b9b">Agda Gist</a></li></ul></div>



<p id="chapo">Last week I talked about <a href="canonical-structures-currying">currying
using Coq's Canonical Structures</a>. This got me thinking about how to
get something similar working in Agda. It turns out that the recently
introduced <span class="inline-code">REWRITE</span> pragma is just what is needed to replicate
this use case.</p>



<p>Let us start with a quick reminder of the problem at hand: the goal is
to be able to write a <span class="inline-code">map</span> function working on lists and automatically
currying its argument as much as possible. Why you ask? Well because we
really don't want to have to define <span class="inline-code">map_tuple</span>, <span class="inline-code">map_triple</span>
and so on with all the possible nestings imaginable.</p>



<a name="section0"></a>
<h3><a class="sectionref" href="#section0">#</a> The definition of <span class="inline-code">Curry</span> and various instances</h3>



<p>The first thing to do is to introduce a record <span class="inline-code">Curry</span> describing
the sort of domains we may curry. You may recognise the structure we used
in <a href="canonical-structures-currying">the previous blog post</a>: this
record packs a domain (<span class="inline-code">dom</span>), a type constructor (<span class="inline-code">cur</span>)
and a proof (<span class="inline-code">prf</span>) that for any codomain <span class="inline-code">cod</span>, one may turn
an element of type <span class="inline-code">cur cod</span> into a function from <span class="inline-code">dom</span> to
<span class="inline-code">cod</span>.</p>



<p class="code">record Curry : Set₁ where
  field
    dom : Set
    cur : Set → Set
    prf : (cod : Set) (f : cur cod) → dom → cod</p>



<p>The next step is to define instances of <span class="inline-code">Curry</span>. The most
obvious instance is probably the one doing nothing: for any domain
<span class="inline-code">A</span>, we can define <span class="inline-code">cur</span> to be the function which
associates <span class="inline-code">A → cod</span> to each codomain <span class="inline-code">cod</span>. The
proof that one can turn <span class="inline-code">A → cod</span> into <span class="inline-code">cur cod</span>
is then trivial.</p>




<p class="code">curryDefault : (A : Set) → Curry
curryDefault A =
  record { dom = A
         ; cur = λ cod → A → cod
         ; prf = λ cod → id
         }</p>



<p>We then explain how to combine two instances of <span class="inline-code">Curry</span> by
taking, as domain, the product of their respective domains. The
definitions of <span class="inline-code">cur</span> and <span class="inline-code">prf</span> become a bit more involved
but should be understandable.</p>



<p class="code">curryPair : (A B : Curry) → Curry
curryPair A B =
  record { dom = dom A × dom B
         ; cur = λ cod → cur A (cur B cod)
         ; prf = λ cod f p → prf B cod
                            (prf A (cur B cod)
                             f (fst p)) (snd p)
         }</p>




<a name="section1"></a>
<h3><a class="sectionref" href="#section1">#</a> Using <span class="inline-code">REWRITE</span> to guide the typechecker</h3>



<p>A <a href="https://github.com/agda/agda/blob/0716021c904186ca806a34fe110ae0fca4a3dd70/src/full/Agda/TypeChecking/Rewriting.hs#L5L42"><span class="inline-code">REWRITE</span> pragma</a>
has recently been introduced to allow the user to define a binary relation
characterizing equations the typechecker should internalise. The primary
goal is, as far as I know, to allow homotopy type theorists to have a bit
of fun with an equality that looks like it computes. But there's no
reason to leave it to them! Obviously, this is an unsafe feature and if
you are not careful when picking your rewrite rules, you will get the
typechecker into an infinite loop. It happened to me a couple of times
whilst drafting this program.</p>



<p>The sole purpose of the <span class="inline-code">Canonical</span> relation we introduce is
to guide the rewriting process. As such, we don't care about its
implementation and can simply postulate it. We also introduce a
<span class="inline-code">Target</span> precisely identifying the candidates for rewriting
in order to avoid to send Agda into an infinite loop by reapplying
the default rule over and over again.</p>



<p class="code">postulate
  Canonical        : (A B : Curry) → Set
  Target           : (A : Set) → Curry
</p>



<p>We can then define two rewrite rules based on our previous combinators.
The order in which they are introduced matters and that is why we start
with the one dealing with pairs so that we only ever use <span class="inline-code">curryDefault</span>
when reaching a base type or a type variable.</p>



<p class="code">postulate
  CanonicalProd    : {A B : Set} → Canonical (Target (A × B)) (curryPair (Target A) (Target B))
  CanonicalDefault : {A : Set} →   Canonical (Target A) (curryDefault A)
</p>



<p>Finally, we use the appropriate pragmas to declare <span class="inline-code">Canonical</span>
as the relation characterizing the equations which should be internalised
and tell Agda to use <span class="inline-code">CanonicalProd</span> and <span class="inline-code">CanonicalDefault</span>
as rewrite rules.</p>



<p class="code">{-# BUILTIN REWRITE Canonical #-}
{-# REWRITE CanonicalProd     #-}
{-# REWRITE CanonicalDefault  #-}</p>



<p>It is now time to define our generic mapping function. Just like last
time, it is preferable to defined a <span class="inline-code">flippedMap</span> in order to fire
the easy constraint <span class="inline-code">List (Target A)</span> first. We define
<span class="inline-code">flippedMap</span> with a domain <span class="inline-code">A</span> which we now to be <span class="inline-code">Curry</span>
and use its <span class="inline-code">prf</span> field to transport the function passed as an
argument.</p>



<p class="code">flippedMap : {A : Curry} {B : Set} (xs : List (dom A)) (f : cur A B)  → List B
flippedMap {A} xs f = map (prf A _ f) xs</p>



<p>We then introduce a slight variation on <span class="inline-code">flippedMap</span> which
turns its argument into a <span class="inline-code">Target</span>. This is a great occasion
to add a bit of syntactic sugar putting the arguments back in their
right order. We choose to stick to applicative style combinators and use
<span class="inline-code">_⟨$⟩_</span>.</p>



<p class="code">flippedMap' : {A B : Set} (xs : List (dom (Target A))) (f : cur (Target A) B)  → List B
flippedMap' {A} = flippedMap {Target A}

syntax flippedMap' xs f = f ⟨$⟩ xs</p>



<p>We can now have a look at a couple of small examples. It should be
noted that our typechecking-time magic does not break anything: these examples
still compute! Indeed normalising <span class="inline-code">example₁</span> yields <span class="inline-code">3 ∷ 5 ∷ []</span>
whilst doing the same for <span class="inline-code">example₂</span> gives us <span class="inline-code">17 ∷ 30 ∷ []</span>.</p>



<p class="code">example₁ : List ℕ
example₁ = _+_ ⟨$⟩ (1 , 2) ∷ (2 , 3) ∷ []

example₂ : List ℕ
example₂ = (λ k l m n → k * l + m * n)
           ⟨$⟩ ((1 , 2) , (3 , 5)) ∷ ((2 , 3) , (4 , 6)) ∷ []</p>



      <hr style="border:0px" />
      <span style="float: right">Last update: 2023 10</span>
    </div>
    <div id="footer" class="flat_list">
    </div>
    <div id="constructivism"><a href="../links.html"><img src="../img/constructivism.png" alt="fun" /></a></div>
  </body>
</html>
