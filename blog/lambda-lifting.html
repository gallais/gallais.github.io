<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Parametrised Modules: (ab)using lambda-lifting</title>
    <link rel="stylesheet" type="text/css" href="../css/main.css" />
    <link rel="alternate" type="application/rss+xml" href="../rss.xml" title="blog">
  </head>
  <body>
    <div id="header">
      <div class="flat_list">
      <ul>
        <li><a href="../index.html">home</a></li>
        <li>||</li>
        <li><a href="../publis.html">publications</a></li>
        <li>||</li>
        <li><a href="../teaching.html">teaching</a></li>
        <li>||</li>
        <li><a href="../thesis.html">thesis</a></li>
        <li>||</li>
        <li><a href="../blog/index.html">blog</a></li>
        <li>||</li>
        <li><a href="../contact.html">contact</a></li>
      </ul>
      </div>
    </div>
    <div id="container">

      <div class="bdocs"><ul><li><a href="https://gist.github.com/gallais/0b3a50e12542f455c010">Self-contained gist</a></li></ul></div>


<p id="chapo">Lately, I have been working quite a bit with
<a href="https://github.com/gallais/type-scope-semantics">an abstract notion
of Semantics</a> defined as a set of combinators all packed in a
record. Doing so, I have come to enjoy the flexibility provided by
parameterised modules to define operations generically over such a
Semantics. In this blog post, I want to show how this pattern can be
used to tidy up some definitions.</p>



<a name="Introduction:ScopeAndLambdaLifting"></a>
<h3><a class="sectionref" href="#Introduction:ScopeAndLambdaLifting">#</a> Introduction: Scope and lambda lifting</h3>



<p>A module declaration in Agda can be parameterised by a telescope of
arguments. These variables are then made available to the user across
the whole body of the module in a manner reminiscent of Coq's
<a href="https://coq.inria.fr/distrib/8.4pl6/refman/Reference-Manual004.html#sec77">Sections</a>.
The most bare-bones example I could come up with is an <span class="inline-code">Identity</span>
module parameterised by <span class="inline-code">A</span>, a <span class="inline-code">Set</span>, and defining the
identity function for <span class="inline-code">A</span>. This definition is accepted without an
out of scope error being raised because, inside the module, the context
is extended with <span class="inline-code">A : Set</span>.</p>



<p class="code">module Identity (A : Set) where

  identity : A → A
  identity = λ x → x
</p>



<p>Once we leave the module, the type of <span class="inline-code">identity</span> as it is
written down does not make sense anymore because <span class="inline-code">A</span>'s scope
was only extending as far as the module was. The process of taking
such a definition and altering it so that it makes sense even outside
of <span class="inline-code">Identity</span> is called
<a href="https://en.wikipedia.org/wiki/Lambda_lifting">lambda-lifting</a>.
It consists in prepending the telescope of arguments the module was
parameterised with

<a id="reftop1" href="#refbot1">[1]</a>

to the type and body of the various defined symbols it contains. We can
check that <span class="inline-code">Identity.identity</span>'s type now includes an extra argument:
the type <span class="inline-code">A</span>. Outside the <span class="inline-code">Identity</span> module, it is effectively
the polymorphic identity

<a id="reftop2" href="#refbot2">[2]</a>

(the highlighted part is the one generated by the lambda-lifting):</p>



<p class="code">check : Identity.identity ∈ <span class="highlight">∀ A →</span> A → A
check = indeed
</p>




<a name="AMoreComplexExample"></a>
<h3><a class="sectionref" href="#AMoreComplexExample">#</a> A more complex example</h3>



<p>In my experience these parameterised modules are particularly helpful
when you need to make the content of a record, passed as an argument,
available to the type and body of a defined symbol. To keep things simple,
I decided to use one of the most basic constructs in the standard library's
<span class="inline-code">Algebra</span>: a <span class="inline-code">RawMonoid</span>. If you have one such beast, then
you can aggregate values by using the monoid's binary operation and
<a href="https://www.youtube.com/watch?v=We90tGh1z3g#t=11m29s">people do
that in <i>real</i> software</a>.</p>



<p>This module is called <span class="inline-code">Reduce</span>, it is parameterised by a <span class="inline-code">RawMonoid</span>

<a id="reftop3" href="#refbot3">[3]</a>

and it implements <span class="inline-code">aggregate</span>, a function which collapses a list
of values down to a single one. Here it is crucial for us to be able
to bring the fields of the <span class="inline-code">RawMonoid mon</span> in scope for the
whole definition: <span class="inline-code">Carrier</span>, <span class="inline-code">_∙_</span> and <span class="inline-code">ε</span> are
all packed up in that record.</p>



<p class="code">module Reduce {c ℓ : Level} (mon : RawMonoid c ℓ) where

  open RawMonoid mon

  aggregate : List Carrier → Carrier
  aggregate = foldr _∙_ ε</p>



<p>It would of course be possible to write an equivalent function without
using such a module: it all amounts to lambda-lifting the definition by
hand. However no matter the approach we choose (bringing the same constants
in scope or projecting the values out of the record), the definitions
become far less readable:</p>



<p class="code">aggregate′ : {c ℓ : Level} (mon : RawMonoid c ℓ) →
             let open RawMonoid mon in List Carrier → Carrier
aggregate′ mon = let open RawMonoid mon in foldr _∙_ ε

aggregate′′ : {c ℓ : Level} (mon : RawMonoid c ℓ) →
              List (RawMonoid.Carrier mon) → RawMonoid.Carrier mon
aggregate′′ mon = foldr (RawMonoid._∙_ mon) (RawMonoid.ε mon)
</p>



<p>We can now use <span class="inline-code">aggregate</span> with an extra argument (the
<span class="inline-code">RawMonoid</span> in question). Assuming we have <span class="inline-code">ℕ+</span> and
<span class="inline-code">ℕ*</span> (respectively the additive and multiplicative monoids over
the natural numbers) and a function <span class="inline-code">[_⋯_]</span> generating a range
of natural numbers, we can write some test about computations involving
<span class="inline-code">aggregate</span>:</p>



<p class="code">test-aggregate : Reduce.aggregate ℕ+ [ 1 ⋯ 5 ] ≡ 15
               ∧ Reduce.aggregate ℕ* [ 1 ⋯ 5 ] ≡ 120
test-aggregate = refl , refl</p>



<p>One last thing I like to do in this sort of situation, especially
when defining what could be considered a semantics, is to anticipate
the lambda-lifting and define an infix operator which uses a double
turnstile (⊨) to separate the specific theory used from the
(parametrically defined) computation it acts upon. Here this would mean
adding the following line <b>inside</b> the module <span class="inline-code">Reduce</span>:</p>



<p class="code">  _⊨reduce_ = aggregate</p>



<p><span class="inline-code">_⊨reduce_</span> is supposed to take two arguments but, inside
<span class="inline-code">Reduce</span>, <span class="inline-code">aggregate</span> only takes one. This weird mismatch
is solved when we leave the module and the <span class="inline-code">RawMonoid</span> argument
is lambda-lifted. We can now write <span class="inline-code">A ⊨reduce xs</span> to mean that we use
the monoid <span class="inline-code">A</span> to give a meaning to the phrase "reduce xs".
The same tests as before hold but I find the type more readable:</p>



<p class="code">test-reduce : ℕ+ ⊨reduce [ 1 ⋯ 5 ] ≡ 15
            ∧ ℕ* ⊨reduce [ 1 ⋯ 5 ] ≡ 120
test-reduce = refl , refl</p>


<a name="Footnotes"></a>
<h3><a class="sectionref" href="#Footnotes">#</a> Footnotes</h3><div class="footnotes"><p class="footnote"><div class="footnote-number"><a id="refbot1" href="#reftop1">[1]</a></div><div class="footnote-body">
This is only a first approximation. It is
naturally possible to have a slightly more subtle approach and to only
prepend the variables which appear free in the type and body of the
defined symbols together will all the ones they themselves depend on
(and so on recursively). In other words, to only use the smallest,
dependency-closed sub-context containing the variables free in the
defined symbol's type and body.
</div></p><p class="footnote"><div class="footnote-number"><a id="refbot2" href="#reftop2">[2]</a></div><div class="footnote-body">
<p>Here we write <span class="inline-code">a ∈ A</span> to mean that <span class="inline-code">a</span> has type <span class="inline-code">A</span>.
This notion can be defined using a simple indexed family which looks a
lot like propositional equality: because of the way the only constructor
<span class="inline-code">indeed</span> is defined, if <span class="inline-code">a ∈ A</span> is inhabited then <span class="inline-code">A</span>
can only ever be <span class="inline-code">a</span>'s type:</p>

<p class="code">data _∈_ {ℓ : Level} {A : Set ℓ} (a : A) : (B : Set ℓ) → Set where
  indeed : a ∈ A
</p>
</div></p><p class="footnote"><div class="footnote-number"><a id="refbot3" href="#reftop3">[3]</a></div><div class="footnote-body">
In the standard library, a <span class="inline-code">Monoid</span> is a <span class="inline-code">RawMonoid</span>
plus some laws. Here we do not care about the proofs that <span class="inline-code">_∙_</span>
is associative and <span class="inline-code">ε</span> a neutral element for it. It goes without
saying that in a general-purpose library, it would be more interesting
to work on a <span class="inline-code">Monoid</span> and prove <span class="inline-code">aggregate</span>'s properties
(e.g. that it is a monoid homomorphism).
</div></p></div>

      <hr style="border:0px" />
      <span style="float: right">Last update: 2023 07</span>
    </div>
    <div id="footer" class="flat_list">
    </div>
    <div id="constructivism"><a href="../links.html"><img src="../img/constructivism.png" alt="fun" /></a></div>
  </body>
</html>
